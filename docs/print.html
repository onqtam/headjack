<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Headjack - the base layer of cyberspace</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=G-6BQMDB9SH6"></script>
                <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
        
                gtag('config', 'G-6BQMDB9SH6');
                </script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> What is Headjack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="principles.html"><strong aria-hidden="true">1.1.</strong> Design - guiding principles</a></li><li class="chapter-item expanded "><a href="identity.html"><strong aria-hidden="true">1.2.</strong> Identity & authorization</a></li><li class="chapter-item expanded "><a href="addressing.html"><strong aria-hidden="true">1.3.</strong> Content addressing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="host_vs_data_centric.html"><strong aria-hidden="true">1.3.1.</strong> Host vs data-centric</a></li><li class="chapter-item expanded "><a href="blobs_and_uris.html"><strong aria-hidden="true">1.3.2.</strong> Blobs & persistent URIs</a></li><li class="chapter-item expanded "><a href="names_and_paths.html"><strong aria-hidden="true">1.3.3.</strong> Names & paths</a></li></ol></li><li class="chapter-item expanded "><a href="messages.html"><strong aria-hidden="true">1.4.</strong> Messages</a></li><li class="chapter-item expanded "><a href="idms_preferences.html"><strong aria-hidden="true">1.5.</strong> IDMs, preferences & graphs</a></li><li class="chapter-item expanded "><a href="store_and_retrieve.html"><strong aria-hidden="true">1.6.</strong> Data storage & retrievability</a></li><li class="chapter-item expanded "><a href="blocks_state_proofs.html"><strong aria-hidden="true">1.7.</strong> Blocks, state & proofs, oh my!</a></li><li class="chapter-item expanded "><a href="numbers.html"><strong aria-hidden="true">1.8.</strong> Throughput & scalability</a></li><li class="chapter-item expanded "><a href="competition.html"><strong aria-hidden="true">1.9.</strong> Headjack vs the competition</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">⬇⬇⬇ WORK IN PROGRESS ⬇⬇⬇</li><li class="spacer"></li><li class="chapter-item expanded "><a href="execution.html"><strong aria-hidden="true">2.</strong> Implementation of Headjack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="IDM.html"><strong aria-hidden="true">2.1.</strong> Identity managers (IDM)</a></li><li class="chapter-item expanded "><a href="handles.html"><strong aria-hidden="true">2.2.</strong> Handles (names)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Headjack - the base layer of cyberspace</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/onqtam/headjack" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="headjack---the-base-layer-of-cyberspace"><a class="header" href="#headjack---the-base-layer-of-cyberspace">Headjack - the base layer of cyberspace</a></h1>
<!-- <object width=100% data="images/Untitled-2022-06-08-1154.svg"></object> -->
<!-- <div width=100% style="background-color:green; overflow:auto;"> -->
<!-- add # before include for the preprocessor to work -->
<!-- {{include images/Untitled-2022-06-08-1154.svg}} -->
<!-- </div> -->
<!-- have to manually remove the size of the svg tag from the file after each export -->
<!-- also should replace href="https:// with href=" after each export -->
<!-- https://github.com/rust-lang/mdBook/issues/773 -->
<p>Headjack is a blockchain that links sovereign identities to content at <a href="principles.html#web-scale-blockspace--the-unix-philosophy">web-scale</a>. Key points:</p>
<ul>
<li>Creation is fundamentally different from transfers and exchange of value - the design space around trust &amp; data availability for media and identity is different from finance.</li>
</ul>
<!-- 
It is not about less or more trust but about better trust.

Headjack is about better trust - not trustlessness

creational - not transactional

# Motto: <s>TRUSTLESS</s> ***BETTER TRUST***

Headjack does sequencing of events.

Breaking apart identity and media allows for better incentives

it does not deal with storage and neither with routing - any kind of routing can be implemented on top of it with the advantage of addressing content in bulk or by source (publisher or creator)

 -->
<ul>
<li>
<p>Following the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">UNIX philosophy</a> - in Headjack identity is simply an identifier (unique number) and anything orthogonal (KYC, profiles, privacy, finance) can be layered on top of it.</p>
</li>
<li>
<p>It solves single sign-on and allows for user experience similar to Web2 through <a href="identity.html">hierarchical authorization management</a> - keypairs are not required by default and even those with keys bound to their accounts may choose to not explicitly sign every interaction.</p>
</li>
<li>
<p>Consensus is reached on the absolute bare minimum - the history of authorizations, names, keys &amp; off-chain content anchors (merkle roots) - the simplest mental model for developers.</p>
</li>
<li>
<p>Headjack can support <strong>billions</strong> of accounts and link <strong>unlimited</strong> amounts of off-chain activity to them. The <a href="principles.html#web-scale-blockspace--the-unix-philosophy">entire web</a> can be rebuilt on top of it - a claim that is <a href="numbers.html">easily provable</a>.</p>
</li>
<li>
<p><a href="addressing.html">Content addressing</a> is with persistent &amp; human-readable URIs (instead of hashes) - the link between identity and data is cryptographically provable even if keys &amp; names have changed.</p>
</li>
<li>
<p>It doesn't deal with off-chain data storage and retrievability - those are separate problems and Headjack simply lets entities point to ways for others to retrieve addressable content.</p>
</li>
</ul>
<!-- - The move from the current [host-centric](host_centric.md#the-host-centric-web--its-decay) web towards [data-centric](host_vs_data_centric.md) addressing represents a paradigm shift around data ownership & access - an architectural reset of the internet. -->
<hr />
<p>The talk <a href="https://www.youtube.com/watch?v=pEl2vLTStWE"><code>&quot;Decentralized identity &amp; content addressing at web-scale&quot;</code></a> at code::dive 2022 is a good high-level overview of the project and covers the most important aspects:</p>
<p><a href="https://www.youtube.com/watch?v=pEl2vLTStWE"><img src="images/youtube_first_talk_thumbnail.png"></a></p>
<h1 id="book-structure"><a class="header" href="#book-structure">Book structure</a></h1>
<ul>
<li><strong>What is Headjack</strong> - How the protocol technically works and how things like applications, services, DMs, social graphs, preferences, etc. could be implemented - the building blocks necessary to recreate anything from Web2 and beyond.</li>
</ul>
<!-- how it compares with other projects -->
<ul>
<li>
<p><strong>Why Headjack</strong> - What's broken with the web and a blueprint for what is possible - services, business models, infrastructure, algorithms, markets, metaverse, etc.</p>
</li>
<li>
<p><strong>Implementation of Headjack</strong> - A detailed specification of the implementation.</p>
</li>
</ul>
<h1 id="what-is-headjack"><a class="header" href="#what-is-headjack">What is Headjack</a></h1>
<!-- The following sub-chapters convey the idea (**what**) and a high-level view of how it works: -->
<ol>
<li><a href="principles.html">Guiding principles &amp; design goals</a></li>
<li><a href="identity.html">Identity &amp; authorization</a></li>
<li><a href="addressing.html">Content addressing</a>
<ol>
<li><a href="host_vs_data_centric.html">Host vs data-centric</a></li>
<li><a href="blobs_and_uris.html">Blobs &amp; persistent URIs</a></li>
<li><a href="names_and_paths.html">Names, paths, &amp; more</a></li>
</ol>
</li>
<li><a href="messages.html">Messages</a></li>
<li><a href="idms_preferences.html">IDMs, preferences &amp; social graphs</a></li>
<li><a href="store_and_retrieve.html">Storage &amp; retrievability of data</a></li>
<li><a href="blocks_state_proofs.html">Blocks, state &amp; proofs, oh my!</a></li>
<li><a href="numbers.html">Throughput numbers (scaling)</a></li>
<li><a href="competition.html">Headjack vs the competition</a></li>
</ol>
<div style="text-align: center;">
    <img src="images/logo.png">
</div>
<p>Named after the <a href="https://matrix.fandom.com/wiki/Headjack">data port at the back of the head</a> of synthetically-grown humans in the Matrix.</p>
<!-- https://www.youtube.com/watch?v=DoUQhYDz-Ys -->
<div style="break-before: page; page-break-before: always;"></div><!--
FIX will/can/should and present tense discrepancies
-->
<h1 id="design---guiding-principles"><a class="header" href="#design---guiding-principles">Design - guiding principles</a></h1>
<p>These are the guiding principles when aiming for mass adoption of Headjack:</p>
<ul>
<li><a href="principles.html#customer-obsession--the-best-possible-ux">Customer obsession &amp; the best possible UX</a></li>
<li><a href="principles.html#web-scale-blockspace--the-unix-philosophy">Web-scale, blockspace &amp; the UNIX philosophy</a></li>
<li><a href="principles.html#decentralization-neutrality--sovereignty">Decentralization, neutrality &amp; sovereignty</a></li>
</ul>
<h1 id="customer-obsession--the-best-possible-ux"><a class="header" href="#customer-obsession--the-best-possible-ux">Customer obsession &amp; the best possible UX</a></h1>
<p>It is highly improbable that the masses (and even most crypto natives) would tolerate services that are much worse (slow, limited &amp; cumbersome) and <a href="competition.html">most of the competing attempts for decentralizing media</a> are nowhere close. There are a few aspects to retaining the comforts and UX of Web2 that we've become so accustomed to:</p>
<img src="images/meme_make_them_learn.png" align="right" style="margin-left: 8px; width: 35%">
<ol>
<li>
<p>Nobody wants to deal with keys, wallets &amp; self-custody because of all the headaches &amp; complexities that come along with that. Creation &amp; media are different from exchange &amp; finance and it's OK to trust by default as long as there's <a href="principles.html#decentralization-neutrality--sovereignty">a fallback</a>. We should be aiming for <strong>better trust</strong> instead of trustlessness at the cost of UX. Users shouldn't have to manage keypairs on multiple devices &amp; explicitly sign every interaction - by default they'll be logging into identity managers (<a href="IDM.html">IDMs</a>) using email &amp; passwords or <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> (<code>&quot;login with Google&quot;</code>) and would then be using these IDMs as <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> to authorize applications to post on their behalf without requiring keys &amp; signatures - by delegating trust. This way the majority of Web2 identity &amp; authentication plumbing can be reused with Headjack underneath as just another backend. <code>&quot;Sign-in with Ethereum&quot;</code> doesn't scale - we should aim for familiarity.</p>
<blockquote>
<p>&quot;With consumer products, simple and “wrong” beats complicated and “right.”&quot; - <a href="https://twitter.com/naval/status/1542651322532384768">@naval</a></p>
</blockquote>
<blockquote>
<p>&quot;The future of mass-market crypto experiences lies within apps that provide familiar, custodial experiences with the ability to graduate into non-custodial experiences.&quot; - <a href="https://future.a16z.com/missing-link-web2-web3-custody-wallets/">a16z</a></p>
</blockquote>
<!-- > "If the goal is to onboard first-time crypto users, the experience must be custodial — at least to start." - [a16z](https://future.a16z.com/missing-link-web2-web3-custody-wallets/) -->
<!-- > "Wallets, seed phrases, and gas for transactions are all inherently very unfriendly to the user, and until greater levels of abstraction exist, adoption will face headwinds. We must assume that the average user will not deal with the complexity we see today." - [Zee Prime capital](https://zeeprime.capital/web-3-middleware) -->
<!-- > "If Web3 social is for the crypto community only - it will likely fail. It’s not enough to provide ideological motives. The key here is to introduce new forms of monetization which overlaps with the aforementioned “Web3 commerce” narrative. These new tools must be intuitive and easy to use." - [@mattigags](https://wrongalot.substack.com/p/the-next-big-crypto-narrative) -->
</li>
<li>
<p>Users shouldn't have to think about and pay for the storage of their data &amp; blockchain interactions by default - costs &amp; complexity should be abstracted away &amp; shifted to services in the background. Self-hosting is the opposite of <a href="https://twitter.com/arvanaghi/status/1537519858233008128">customer obsession</a> - let's aim for simplicity.</p>
<blockquote>
<p>&quot;People don’t want to run their own servers, and never will.&quot; - <a href="https://moxie.org/2022/01/07/web3-first-impressions.html">Moxie</a></p>
</blockquote>
</li>
<li>
<p>Content addressing should be with human-friendly URIs with names &amp; numbers instead of being full of hashes - typical for Web3. We're used to adequate URLs where the domain of the platform/website &amp; even the user name are present when identifying content - hashes make URIs much longer &amp; harder to remember. Contrast that to <a href="addressing.html">Headjack's addressing</a>.</p>
</li>
<li>
<p>The applications built on top of the network must match the responsiveness of Web2 and exceed its functionality. <code>&quot;Latency is not an option anymore&quot;</code> - Amazon <a href="https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales">found</a> that every 100ms of latency cost them 1% in sales. 16 years ago Google <a href="http://glinden.blogspot.com/2006/11/marissa-mayer-at-web-20.html">found</a> an extra 500ms in search page generation time dropped traffic by 20% - our irritable nature hasn't changed. Web2 isn't going anywhere - <a href="https://moxie.org/2022/01/07/web3-first-impressions.html"><code>&quot;market dynamics and the fundamental forces of centralization&quot;</code></a> dictate that the best services will be running on huge server racks in data centers with sophisticated caches &amp; batch processing infrastructure due to data gravity.</p>
<img src="images/data_gravity.png">
</li>
</ol>
<!-- source: https://www.tigosolutions.com/feedstory/1030 -->
<!-- <img src="images/meme_web2_web3_hands.jpg" align="right" style="margin-left: 8px; width: 35%"> -->
<h1 id="web-scale-blockspace--the-unix-philosophy"><a class="header" href="#web-scale-blockspace--the-unix-philosophy">Web-scale, blockspace &amp; the UNIX philosophy</a></h1>
<p>People grossly underestimate the size of the web and the required infrastructure. Here are some decade old <a href="https://www.internetlivestats.com/twitter-statistics/">twitter</a>, <a href="https://www.internetlivestats.com/google-search-statistics/">google</a> and <a href="https://www.internetlivestats.com/">other</a> statistics and a few articles about what it takes to run Twitter: <a href="http://highscalability.com/blog/2009/10/13/why-are-facebook-digg-and-twitter-so-hard-to-scale.html">1</a>, <a href="http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html">2</a>, <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2016/the-infrastructure-behind-twitter-efficiency-and-optimization">3</a>, <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2017/the-infrastructure-behind-twitter-scale">4</a>, <a href="https://blog.twitter.com/engineering/en_us/topics/infrastructure/2021/processing-billions-of-events-in-real-time-at-twitter-">5</a>. What was going on within a single minute of 2021 is <a href="https://www.domo.com/learn/infographic/data-never-sleeps-9"><ins>truly mind-boggling</ins></a>:</p>
<!-- (this picture is very incomplete) -->
<img src="images/web_scale_techspot.webp">
<!--
https://www.techspot.com/news/91513-visualizing-minute-internet-2021.html
https://www.domo.com/data-never-sleeps
https://www.domo.com/blog/data-never-sleeps-hits-double-digits/
https://web-assets.domo.com/miyagi/images/product/product-feature-22-data-never-sleeps-10.png -->
<!-- <img src="https://static.techspot.com/images2/news/bigimage/2021/09/2021-09-30-image-32-j.webp"> -->
<p>Headjack follows the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">UNIX philosophy</a> - it focuses only on <a href="identity.html">identity</a> (identifiers represented as numbers &amp; name ownership) &amp; linking data/actions to it without trying to do anything orthogonal (data storage, KYC, profiles, privacy, finance, etc.) that can be layered on top. It doesn't impose constraints on what could be built around it - <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>. All kinds of systems with their own incentives, cryptoeconomics &amp; guarantees can be implemented on top of this identity layer &amp; <a href="addressing.html">addressing</a>. The on-chain vs off-chain tradeoff and what goes into the blockspace is as follows:</p>
<!-- > "Expect the output of every program to become the input to another, as yet unknown, program." - [Unix Philosophy, Bell System Technical Journal, Jul-Aug 1978](https://archive.org/details/bstj57-6-1899) -->
<!-- > "By basing design on increasing levels of abstraction, layering greatly reduces complexity… Since each layer only uses the services of layers below, a layered system can be implemented and tested incrementally." - [Internet Architecture and Innovation](https://www.goodreads.com/book/show/8586192-internet-architecture-and-innovation) -->
<ul>
<li>
<p>Consensus should be reached on the absolute bare minimum - only <a href="identity.html">identity</a> (integers), the history of keypairs &amp; authorizations, name ownership &amp; anchors to off-chain activity need <a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">logical centralization</a> and must be on-chain with guaranteed data availability.</p>
</li>
<li>
<p>All other activity &amp; data is stored off-chain (<a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">IPFS</a> &amp; other protocols) because of the sheer volume - it's ephemeral and its relevance fades with time. Most of it won't be stored forever but any piece can be backed up through archives &amp; <a href="IDM.html">IDMs</a>. Events get cryptographically anchored with <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle roots</a> to the chain so that permissions, inclusion &amp; sequence are provable.</p>
</li>
</ul>
<blockquote>
<p>&quot;Developers care about risk.&quot; - <a href="https://haseebq.com/why-decentralization-isnt-as-important-as-you-think/">Haseeb</a></p>
</blockquote>
<p>It must be <a href="numbers.html"><strong>obvious &amp; provable</strong></a> that the network has a <strong>credible path to handling billions of users</strong> if entrepreneurs are expected to jump on the opportunity. The easiest mental model will win over developers and users - <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singletons</a> &amp; opinionated frameworks with a concrete direction are much simpler than a fractured landscape of standards, chains &amp; bridges.</p>
<!-- Most crypto projects are toys compared to what Web2 has been doing in the past couple of decades -->
<blockquote>
<p>&quot;Consistency is incredibly important for creating a compelling user experience.&quot; - <a href="https://signal.org/blog/the-ecosystem-is-moving/">Moxie</a></p>
</blockquote>
<h1 id="decentralization-neutrality--sovereignty"><a class="header" href="#decentralization-neutrality--sovereignty">Decentralization, neutrality &amp; sovereignty</a></h1>
<blockquote>
<p>&quot;The Internet has succeeded in no small part because of its purposeful avoidance of any single controlling entity.&quot; - <a href="https://www.ietf.org/archive/id/draft-nottingham-avoiding-internet-centralization-05.html">source</a></p>
</blockquote>
<ul>
<li>
<p><strong>Sovereignty</strong>: Users should be able to own their identity &amp; connections with a keypair <strong>even if by default</strong> their activity is managed by an <a href="IDM.html">IDM</a> - resembling a custodial service.</p>
</li>
<li>
<p><a href="https://nakamoto.com/credible-neutrality/"><strong>Credible neutrality</strong></a> - Anyone can permissionlessly have a pseudonymous identity, buy a name, operate an <a href="IDM.html">IDM</a>, serve media through an application and publish &amp; broadcast through Headjack using their identity. <a href="moderation.html">Moderation &amp; censorship</a> happen at the application &amp; infrastructure level - freedom of speech is guaranteed, but not freedom of reach as that is up to the applications &amp; services that serve media. Individuals will always be able to contact one another for private communication.</p>
</li>
<li>
<p>Anyone can self-host &amp; run software locally, browse the ecosystem, and fetch content &amp; events from entities they've subscribed to (although quite bandwidth-intensive), but their experience will be extremely limited in that they won't be able to run any sort of query/filtration/feed algorithm at scale nor aggregate the activity of billions of people in real-time.</p>
</li>
</ul>
<blockquote>
<p>&quot;You can build something centralized on something decentralized but you can’t build something decentralized on top of something centralized. Decentralization is always the base layer.&quot; - <a href="https://twitter.com/RyanSAdams/status/1553776203621965826">@RyanSAdams</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identity--authorization"><a class="header" href="#identity--authorization">Identity &amp; authorization</a></h1>
<p>There are 3 types of roles in Headjack (although a single entity may play all 3):</p>
<ul>
<li>Normal accounts - represented by an integer ID on-chain - keypair association is optional.</li>
<li><a href="IDM.html">IDMs</a> - a superset of normal accounts - required to have a keypair - can manage other accounts by submitting changes for them (name handle, updating keypairs) &amp; acting as <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> - authorizing applications to post on behalf of users (&amp; ability to revoke the authorization). They will also be responsible for handling DMs as discussed <a href="IDM.html#dms">here</a>.</li>
<li>Applications - a superset of normal accounts - required to have a keypair - they are the media presentation layer. Users can authorize them through the use of an <a href="IDM.html">IDM</a> to post on their behalf without having to explicitly sign every interaction (follow, post, comment, react).</li>
</ul>
<p>All authorizations are represented &amp; submitted on-chain as simple integer pairs (<code>2131 =&gt; 83253, 6331 =&gt; 14415</code>) that get aggregated in compact blobs &amp; signed in bulk by <a href="IDM.html">IDMs</a> - achieving a very high signal-to-noise ratio (few signatures) ==&gt; improving the throughput in the valuable block space.</p>
<img src="images/sequenced_integer_relations.png">
<p>With this foundation we achieve the following range of usage scenarios:</p>
<ul>
<li>Costs for using the blockchain can be shifted to <a href="IDM.html">IDMs</a> &amp; applications with business models to support that - users won't care that there's an underlying token (they'll always be able to interact with it directly through the mempool &amp; pay for transactions if they wish).</li>
<li>Users won't need wallets &amp; keypairs - risky and cumbersome with multiple devices. Most will create accounts through <a href="IDM.html">IDMs</a> &amp; use email/pass or Web2 <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> (<code>&quot;login with Google&quot;</code>) which will create on-chain integer IDs for them without associated keypairs - &quot;owned&quot; by the custodian. Users will be able to &quot;log in&quot; to applications using their IDM as <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> for Headjack which will authorize the application with a few bytes on-chain to post actions on behalf of users - all without requiring a single signature by the user - neither on-chain for the identity/authorizations (tiny bits of data - just integers &amp; bit flags submitted by the <a href="IDM.html">IDM</a>) nor for their off-chain content (posts, comments, reactions).</li>
<li>Users can revoke permissions to applications and even retroactively invalidate activity generated on their behalf by an application by saying <code>&quot;discard activity generated through application А from block X forward&quot;</code> through a small on-chain message published by their IDM because everything is sequenced. This is acceptable because in this blockchain <a href="https://twitter.com/VitalikButerin/status/1530268923848839173">such data is non-financial</a> and fake activity has smaller consequences - it is still an enormous improvement compared to the current Web2 status quo.</li>
<li>At any point in time users can regain full sovereignty over their identities by binding a keypair through their <a href="IDM.html">IDM</a>. Then they'll be able to cut that IDM off (revoke access) &amp; even retroactively invalidate actions from it through another IDM or direct on-chain transactions.</li>
<li>Users can be completely anonymous by directly creating an identity with a keypair &amp; paying for an on-chain transaction. They'll be able to use <a href="IDM.html">IDMs</a> without having to sign with email/pass or a Web2 <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> - not revealing anything.</li>
<li>Applications will be usable by users that don't use an <a href="IDM.html">IDM</a> but all their off-chain activity (posts, comments, reactions) will need explicit signatures.</li>
</ul>
<img src="images/authorizations.png">
<p>So at the core of it all is just sequencing relations between integers &amp; Merkle roots for content.</p>
<img src="images/meme_integers_and_relations.jpg">
<p>In practice, we expect that only cypherpunks &amp; people that have something to lose (big audience/reputation) will go through the trouble to manage a keypair. Almost everyone will use <a href="IDM.html">IDMs</a> - even most crypto natives don't want to explicitly sign every action and have their keys in hot wallets ready to get hacked. This way 99.9% of the user activity on-chain (mostly authorizations) ends up going through authorized services and gets batched in a compact way - requiring only that the service signs the aggregated payload and thus reducing the amount of signatures on-chain.</p>
<p>The vast majority of users will be lightweight: consumers &amp; curators of content (through interactions &amp; reactions) with very little creation on their part and little to no audience. At any point in time, they could shift to a more vocal role and start caring about archiving their off-chain data and not relying on the good grace of the infrastructure that sits beneath applications.</p>
<!-- https://en.wikipedia.org/wiki/1%25_rule -->
<p>Key &amp; session management (rotation, authorization &amp; revocation) <a href="https://blog.ceramic.network/key-revocation-in-self-certifying-protocols/">require</a> ordering that is <a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">logically centralized</a>. It is compatible with any type of <a href="https://www.w3.org/TR/did-core/">DID</a> - anything could be associated with an integer ID. The on-chain authorization has great synergy with the human-readable &amp; persistent <a href="addressing.html">addressing</a> for off-chain content.</p>
<!-- meme: oprah - you get an identity, you get an identity, everyone gets an identity! -->
<!-- TODO: talk about per device key revocation - or how IDMs will be able to track which devices are logged in and they should handle such revocation - as in the traditional Web2 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="content-addressing"><a class="header" href="#content-addressing">Content addressing</a></h1>
<p>The move from host-centric to data-centric addressing is a complete paradigm shift by itself but Headjack intertwines that with names, on-chain authorization and sequencing of anchors resulting in the best possible <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URIs</a> in terms of human-readability &amp; persistence - perhaps the most important aspect of the project. This chapter is broken down into a few sub-chapters:</p>
<ol>
<li><a href="host_vs_data_centric.html">Host vs data-centric</a></li>
<li><a href="blobs_and_uris.html">Blobs &amp; persistent URIs</a></li>
<li><a href="names_and_paths.html">Names, paths, &amp; more</a></li>
</ol>
<img src="images/telephone_switchboard_1.png">
<!-- source:
https://culturexchange1.files.wordpress.com/2015/06/sans-titre.png
https://culturexchange1.wordpress.com/2015/06/02/the-telephone-switchboard-the-story-of-a-revolutionary-instrument/
-->
<!-- <img src="images/telephone_switchboard_2.webp"> -->
<!-- source:
https://api.time.com/wp-content/uploads/2015/08/phones1.jpeg
https://time.com/4011936/emma-nutt/
-->
<div style="break-before: page; page-break-before: always;"></div><!--
TODO: look at:

tls-n
Look at ct
Openid connect
Tos evidence extensions
Google amp - signed caches
Chainlink authenticated data origination
-->
<h1 id="host-vs-data-centric"><a class="header" href="#host-vs-data-centric">Host vs data-centric</a></h1>
<p>Let's take a look how the web works and what are the building blocks &amp; ideas that enable Headjack:</p>
<ul>
<li><a href="host_vs_data_centric.html#todays-web-host-centric">Today's web: host-centric</a></li>
<li><a href="host_vs_data_centric.html#data-centric-computing">Data-centric computing</a></li>
<li><a href="host_vs_data_centric.html#content-addressable-storage">Content-addressable storage</a></li>
<li><a href="host_vs_data_centric.html#information-centric-networking">Information-centric networking</a></li>
<li><a href="host_vs_data_centric.html#named-data-networking">Named Data Networking</a></li>
<li><a href="host_vs_data_centric.html#enter-headjack---the-final-iteration">Enter Headjack - the final iteration</a></li>
</ul>
<h1 id="todays-web-host-centric"><a class="header" href="#todays-web-host-centric">Today's web: host-centric</a></h1>
<p>Today's web revolves around hosts &amp; <a href="https://en.wikipedia.org/wiki/Unicast">unicast</a> communication - we query <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a> to get the IP of servers and open direct connections with them to retrieve the data that they host. But domains, URI paths on servers &amp; the actual files all change &amp; go away which leads to <a href="https://en.wikipedia.org/wiki/Link_rot">link rot</a> &amp; content drift. Guidance such as <a href="https://www.w3.org/Provider/Style/URI">&quot;Cool URIs don't change&quot;</a> is just that - guidance - and the <a href="https://en.wikipedia.org/wiki/Internet_Archive">Internet Archive</a> is just a bandaid that can hardly keep up with the digital <a href="https://en.wikipedia.org/wiki/Memory_hole">memory hole</a>. In the host-certified paradigm URLs at best point to a location at which a document may have been available at some point in time - devoid of any cryptographic proofs regarding the contents, the creator, an alternative way to retrieve it or the time of publication. The implications are explored in the <a href="host_centric.html#the-host-centric-web--its-decay">host-centric section in the motivation</a>.</p>
<blockquote>
<p>&quot;It is generally recognized that the current approach of using IP address both as a locator and as an identifier was a poor design choice.&quot; - <a href="https://en.wikipedia.org/wiki/David_D._Clark">David D. Clark</a>, <a href="https://www.goodreads.com/book/show/39644174-designing-an-internet">Designing an Internet</a></p>
</blockquote>
<div style="position: relative;width: 100%;height: 0;padding-bottom: 56.25%;">
<iframe style="position: absolute;top: 0;left: 0;width: 100%;height: 100%;" src="https://www.youtube-nocookie.com/embed/DdaElt6oP6w" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
<h1 id="data-centric-computing"><a class="header" href="#data-centric-computing">Data-centric computing</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Data-centric_computing">Data-centric computing</a> is an emerging concept that has relevance in information architecture and data center design - data is stored independently of the applications, which can be upgraded without costly and complicated data migration. This is a radical shift in information systems that will be needed to address organizational needs for storing, retrieving, moving, and processing exponentially growing data sets. It increases agility by prioritizing data transfer and data computation. Applications become short-lived, constantly added, updated, or removed as algorithms come and go.</p>
<blockquote>
<p>&quot;Data is the center of the universe; applications are ephemeral.&quot; - <a href="http://datacentricmanifesto.org/">The Data-Centric Manifesto</a></p>
</blockquote>
<h1 id="content-addressable-storage"><a class="header" href="#content-addressable-storage">Content-addressable storage</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Content-addressable_storage">Content-addressable storage</a> (CAS) is a way to store information so it can be retrieved based on its content (not its location/name) and is a key piece of the puzzle. Identifiers are based on content and any change to a data element will necessarily change its content address. The most famous example of CAS is <a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">IPFS</a> but it suffers from non-human-friendly addresses (hashes), performance issues, and extreme latency (tens of minutes) because of the global <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">DHT</a> if content is not widely cached/pinned.</p>
<p><a href="https://en.wikipedia.org/wiki/Self-authenticating_document">Self-authenticating data</a> moves authority from hosts to users. The three components that enable it are <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">cryptographic identifiers</a>, <a href="https://en.wikipedia.org/wiki/Content-addressable_storage">CAS</a>, and an emerging area of research called <a href="https://en.wikipedia.org/wiki/Verifiable_computing">verifiable computation</a> which is yet to be applied in any meaningful scale.</p>
<h1 id="information-centric-networking"><a class="header" href="#information-centric-networking">Information-centric networking</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Information-centric_networking">Information-centric networking</a> (ICN) is an approach to evolving the Internet infrastructure away from a host-centric paradigm, based on perpetual connectivity and the <a href="https://en.wikipedia.org/wiki/End-to-end_principle">end-to-end principle</a>, to a network architecture in which the focal point is identified information (or content or data). Data becomes independent from location, application, storage, and means of transportation, enabling in-network caching and replication. The expected benefits are improved efficiency, better scalability with respect to information/bandwidth demand, and better robustness in challenging communication scenarios. In information-centric networking, the cache is a network-level solution, and it has rapidly changing cache states, higher request arrival rates, and smaller cache sizes.</p>
<h1 id="named-data-networking"><a class="header" href="#named-data-networking">Named Data Networking</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Named_data_networking">Named Data Networking</a> (NDN) is a <a href="https://en.wikipedia.org/wiki/Future_Internet">Future Internet</a> architecture that builds on top of the previous ideas (&amp; an incarnation of ICN) and in which data is requested by name and routed by the network. However, there are many unsolved challenges with it like the need to reimplement foundational routing infrastructure to make it stateful and hierarchically structured names which require a root name authority to link them to keypairs - outside of its scope. Here's <a href="https://www.youtube.com/watch?v=oCZMoY3q2uM">a great lecture</a> on the topic.</p>
<h1 id="enter-headjack---the-final-iteration"><a class="header" href="#enter-headjack---the-final-iteration">Enter Headjack - the final iteration</a></h1>
<p>Headjack is a weird amalgamation inspired by everything above - it provides human-readable &amp; persistent <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URIs</a> for self-authenticating data (with <a href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5">Merkle proofs</a> &amp; the blockchain) along with the means for its retrieval without forcing a specific way (<a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">IPFS</a> is just one option). It acts as the web-scale global index used to check the authenticity of documents (requires consulting with the chain), ownership of names, key management &amp; sequence of events throughout time. It is an addressability layer on top of the current host-centric internet technologies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blobs--persistent-uris"><a class="header" href="#blobs--persistent-uris">Blobs &amp; persistent URIs</a></h1>
<p>This chapter will explain how all off-chain <a href="messages.html">messages</a> (actions/events/content) get published:</p>
<ul>
<li><a href="blobs_and_uris.html#blob-construction---batching-of-user-events">Blob construction - batching of user events</a></li>
<li><a href="blobs_and_uris.html#stable-intra-blob-addressing-before-publishing">Stable intra-blob addressing before publishing</a></li>
<li><a href="blobs_and_uris.html#persistent--provable-uris">Persistent &amp; provable URIs</a></li>
<li><a href="blobs_and_uris.html#steps-to-prove-the-authenticity-of-a-uri">Steps to prove the authenticity of a URI</a></li>
<li><a href="blobs_and_uris.html#a-few-other-notes">A few other notes</a></li>
</ul>
<h1 id="blob-construction---batching-of-user-events"><a class="header" href="#blob-construction---batching-of-user-events">Blob construction - batching of user events</a></h1>
<p>Applications accumulate off-chain activity from users which they cryptographically anchor in batches with a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle root</a> on-chain and they determine how often to do so (it doesn't have to be on every block) - those with little activity may submit only once per minute or even less often - the frequency is determined by applications based on the volume of activity and the on-chain publishing costs.</p>
<p>When enough activity has been collected it is time for the application to finalize the batch: it is packed in a blob and all the events generated since the last anchored batch are sorted &amp; grouped by accounts in some deterministic way (perhaps accounts based on index and actions based on the type/sequence) with some schema with the following steps:</p>
<ol>
<li>The intra-blob index (offset table) for lookup of content of specific accounts is generated.</li>
<li>A <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle root</a> that touches every event is deterministically constructed following a schema.</li>
<li>The <a href="https://docs.ipfs.io/concepts/content-addressing/">IPFS CID</a> (hash) for the blob is generated and it is pinned for others to download.</li>
</ol>
<p>The only 2 things that are signed &amp; submitted on-chain are thus the Merkle root and the IPFS CID for the next nonce (auto-increment counter) associated with the application account.</p>
<img src="images/blob_structure.png">
<!-- <object width=100% data="images/blob_structure.svg"></object> -->
<h1 id="stable-intra-blob-addressing-before-publishing"><a class="header" href="#stable-intra-blob-addressing-before-publishing">Stable intra-blob addressing before publishing</a></h1>
<p>Applications maintain the logical order of events for the future batch in maps in order to provide intra-blob addressing even before it is fully constructed - as an example if a user posts an article and immediately after that comments on their own post - the comment should be able to refer to the post which is not yet committed on-chain. Applications will also display activity by other accounts that is not yet anchored and the interactions can still use the proper addressing when referring to the yet-to-be-anchored messages (the next nonce number is known in advance). Any type of interaction is addressable and sequenced in the blobs - including reactions (likes, etc).</p>
<h1 id="persistent--provable-uris"><a class="header" href="#persistent--provable-uris">Persistent &amp; provable <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URIs</a></a></h1>
<p>Each account has an associated auto-increment counter (nonce) for every time they submit an anchor for off-chain content. So if an application has submitted 2 times already, then the next submission will be with <code>nonce == 3</code>. The blockchain keeps a mapping in its state for each previous nonce value to the block number when it changed so that <code>&lt;application_id&gt;/&lt;nonce&gt;</code> can be translated to which block has the Merkle root anchor &amp; <a href="https://docs.ipfs.io/concepts/content-addressing/">IPFS CID</a> for the blob that corresponds to that nonce for that account.</p>
<!-- The 2 can be extracted from the block. -->
<img src="images/blob_URI.png">
<p>Once a blob is fetched through the <a href="https://docs.ipfs.io/concepts/content-addressing/">IPFS CID</a> (hash) we can address specific events by using the offset index in the blob header so a URI like <code>&lt;application_id&gt;/&lt;nonce&gt;/&lt;user_id&gt;/&lt;content_id&gt;</code> can point to a specific post, comment or even reaction (activity is grouped by users). The content ID for a specific user is usually a small single-digit number and is necessary only if there has been more than 1 interaction by that user through that application for the given nonce (maybe rare). This is what events with URIs referring to each other looks like:</p>
<img src="images/content_references.png">
<p>The blockchain can be queried if the application was allowed to post content on behalf of the user with an on-chain authorization (which probably happened through an <a href="IDM.html">IDM</a>) when that specific block was published in order to determine if the activity is authentic - the state keeps information for each account such as since what block number a given application was authorized to post on behalf of a user (and until when - all ranges). Users may avoid using IDMs and explicitly sign their actions in which case their data will be accompanied by their signatures within the data blobs and the only check required will be for the user keypair used for the specific block number.</p>
<h1 id="steps-to-prove-the-authenticity-of-a-uri"><a class="header" href="#steps-to-prove-the-authenticity-of-a-uri">Steps to prove the authenticity of a URI</a></h1>
<p>To recap - to prove the authenticity of any event with a URI:</p>
<ul>
<li>First check if the data is actually part of an anchored blob with a <a href="https://medium.com/crypto-0-nite/merkle-proofs-explained-6dd429623dc5">Merkle proof</a> to a block. This requires either just the piece of data + a Merkle proof for inclusion in the blob or the entire blob in order to reconstruct the Merkle tree &amp; proof.</li>
<li>Then check if the user actually submitted the event:
<ul>
<li>Either if at that point the application was authorized to post on behalf of the user which would require a Merkle proof for a part of the blockchain state (authorization ranges).</li>
<li>Or by checking for an explicit signature &amp; the public key of that account at that time which would also require a Merkle proof for a part of the blockchain state (account key history).</li>
</ul>
</li>
</ul>
<p>URIs are persistent as long as someone hosts either the individual event + the Merkle proof or the entire blob (and can reconstruct the proof) and knows to which block it was anchored (from the <code>&lt;application_id&gt;/&lt;nonce&gt;</code> =&gt; <code>&lt;block_number&gt;</code> mapping). The <a href="names_and_paths.html">following chapter</a> shows how names in URIs are persistent too (even if user/application names change ownership at some point).</p>
<h1 id="a-few-other-notes"><a class="header" href="#a-few-other-notes">A few other notes</a></h1>
<ul>
<li>There can be many different &amp; valid proofs for the same URI from different block heights.</li>
<li>Even private <a href="https://en.wikipedia.org/wiki/Intranet">intranet</a> data may be anchored but not retrievable by the public if the blob IPFS CID is never published or pinned/hosted - unified addressing for public &amp; private.</li>
<li>Users should be able to see the URI of content even if created through another application and the origin should be displayed by default - acting as <a href="business_models.html">attribution for other applications</a>.</li>
<li>Edits &amp; updates to content come as <a href="messages.html">messages</a> with new unique URIs that reference the older message URIs and it is up to applications to properly handle this - either by showing that there have been changes and a newer version or automatically redirect to the latest. &quot;Forks&quot; are possible but they represent application failure to detect that an old version is being edited.</li>
<li>Accounts that anchor content on-chain cannot do so twice in the same block - for simplicity.</li>
</ul>
<!--

Blob construction is a trivially parallelizable problem

# On proof permanence

One thing to consider is if a user revokes the authorization of an application to post on their behalf retroactively - not just going forward but also invalidating all anchored content & follow/unfollow events for the last couple of days through that application. This would mean that cached Merkle proofs for such invalidated content will no longer be valid and the latest state of the blockchain will refuse to produce new such proofs, but the cached proofs could mislead someone. Retroactive revocation can happen only up to `X` days to limit the scope of changes to cached proofs & what infrastructure would need to handle but still give enough time for anyone to react in case an application has posted fraudulent activity on their behalf - a **mostly theoretical concern**. Proofs for blocks older than `X` days are therefore considered permanent.
--><div style="break-before: page; page-break-before: always;"></div><h1 id="names--paths"><a class="header" href="#names--paths">Names &amp; paths</a></h1>
<p>Headjack is also a name registry - accounts can own a handle and be identified with it. For specifics around the details (constraints, subdomains, auctions, distribution, hoarding, leasing, etc.) please refer to <a href="handles.html">their dedicated page</a>. In this chapter:</p>
<ul>
<li><a href="names_and_paths.html#names-in-uris">Names in URIs</a></li>
<li><a href="names_and_paths.html#what-to-ask-the-blockchain-about-a-uri">What to ask the blockchain about a URI</a></li>
<li><a href="names_and_paths.html#web3-uris-interoperable-in-web2">Web3 URIs interoperable in Web2</a></li>
<li><a href="names_and_paths.html#content-titles-in-uris">Content titles in URIs</a></li>
<li><a href="names_and_paths.html#addressing-within-content">Addressing within content</a></li>
</ul>
<h1 id="names-in-uris"><a class="header" href="#names-in-uris">Names in URIs</a></h1>
<p>Users and applications don't need a name and can operate as an integer index just fine, but the preferred case will be with handles. Names can change ownership but the blockchain will be able to translate <code>&lt;application_name&gt;/&lt;nonce&gt;/&lt;user_name&gt;/&lt;content_id&gt;</code> with strings into the canonical integer form discussed <a href="uris.html">previously</a> by substituting the application &amp; user names with account IDs.</p>
<p>Every name has an associated auto-increment nonce (just like account IDs) for every time they submit an anchor for off-chain content and the blockchain records maps of <code>&lt;name&gt;/&lt;nonce&gt;</code> to <code>&lt;id&gt;/&lt;nonce&gt;</code> which can then be used to resolve the URI as discussed in the <a href="uris.html">previous chapter</a>.</p>
<img src="images/account_name_state.png">
<p>But we need to be able to translate not just the application name but also the user name which may have changed ownership at any point - for that the blockchain keeps track of the account ID ownership of every name historically as ranges (from block X to block Y name N was owned by account A) so when we determine the block number for a given data blob we'd be able to check to which account ID does a name in a URI correspond to at that time.</p>
<!-- Additionally the user name <=> account ID mapping at the time of the blob could be embedded within the blob header (along with proofs) so that fewer queries are necessary to the blockchain. -->
<p>And thus we're able to have URIs such as <code>twitter.com/55212/johnny/3</code> to identify any event by any actor - all we'd need to do is a few lookups and we'll be able to use Merkle proofs for any piece of content to prove authenticity. Most URIs could even omit the 4th part because probably there won't be more than 1 action by a user for a given batch by an application.</p>
<p>Note that the canonical form (numbers instead of names) of <code>twitter.com/55212/johnny/3</code> could be something like <code>42/783/523/3</code> where only the last number would be the same and the nonce would most likely be different. Also <code>twitter.com</code> might no longer be owned by account <code>42</code> but what matters is that the blockchain can correctly determine who owned it at nonce <code>55212</code>. Multiple names can be owned by an account but their nonces for one event will probably be different.</p>
<h1 id="what-to-ask-the-blockchain-about-a-uri"><a class="header" href="#what-to-ask-the-blockchain-about-a-uri">What to ask the blockchain about a URI</a></h1>
<p>To recap: we can ask the following questions about this URI: <code>twitter.com/55212/johnny/3</code>:</p>
<ol>
<li>To which application account ID &amp; nonce does <code>twitter.com/55212</code> correspond?</li>
<li>To which block does the applicationID/nonce map correspond?</li>
<li>What is the <a href="https://docs.ipfs.io/concepts/content-addressing/">IPFS CID</a> &amp; Merkle root of the anchored blob at that block?</li>
<li>What account ID does <code>johnny</code> correspond to in the block where this blob was anchored?</li>
<li>Once we download the blob or just the blob header (using the IPFS CID or any other means):
<ol>
<li>We can ask the offset table where within the blob is <code>johnny</code>'s content № <code>3</code>?</li>
<li>Once we fetch the actual data &amp; depending on whether it is explicitly signed or not:
<ol>
<li>either if the application was authorized to post on behalf of <code>johnny</code> at that time,</li>
<li>or if the signature matches the keypair that's been bound to <code>johnny</code>'s account at the time of the anchored block.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="web3-uris-interoperable-in-web2"><a class="header" href="#web3-uris-interoperable-in-web2">Web3 URIs interoperable in Web2</a></h1>
<p>Application accounts can point on-chain to a host with an IP address which can be used to display content published through them. Application names can also resemble traditional domain names so it will be possible to copy-paste such URIs directly into your browser and as long as they own the same domain in the traditional <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a> they should be able to serve a webpage displaying the piece of content - enabling seamless interoperability during the transition from one paradigm to the other.</p>
<h1 id="content-titles-in-uris"><a class="header" href="#content-titles-in-uris">Content titles in URIs</a></h1>
<p>Most Web3 platforms <a href="https://twitter.com/hasufl/status/1537388439259291649">suffer from unreadable URIs</a> but we've done a lot better - note the brevity and lack of hashes &amp; hexadecimal symbols (<code>0xf56a0...</code>) - in fact, this is as good as it gets...</p>
<p><strong>Or is it?!</strong> What about headlines of articles - can we have them included as well - something like <code>twitter.com/55212/johnny/3/how-I-went-from-vegan-to-keto-and-back-again</code>? Absolutely! The string is not at all necessary to resolve the piece of content (just like in StackOverflow where the database key for a question is just a number (example: <a href="https://stackoverflow.com/questions/4">question 4</a>) but the page router always changes the URL when loading the page to include the title too). <a href="messages.html">Message types</a> for posts with titles will have a dedicated field which will get included in the content hash and thus spoofing the title will be rejected by conforming applications as it would be a trivial check.</p>
<div style="text-align: center;">
    <img src="images/meme_drake_human_readable_hashes.jpg">
</div>
<!-- Web3 URIs
full of hashes:

https://mirror.xyz/0xE4f6
46F0Be4fF5ce185540F
5366295f91d75b65D/-xp
mr7ceHmi5Hqsl7zRtig9p
h_dtCvWjZOoWOVN0bcg

Persistent
Headjack URIs:

https://someapp.com
/527/johnny/3/how-I-
went-from-vegan-to-
keto-and-back-again

https://imgflip.com/memegenerator/Drake-Hotline-Bling -->
<h1 id="addressing-within-content"><a class="header" href="#addressing-within-content">Addressing within content</a></h1>
<p>Different schemas could be used for addressing within pieces of content (like a paragraph from an article or a clip from audio/video - without losing the context of the whole) and message types could have by default associated on-chain schemas (or the schema of choice could be embedded within the header of the message). For example, when <code>medium.com/12475/elvis/0/learn-to-code/121/66</code> is being loaded the associated schema will be looked up depending on the type of message (in this case - an article) and used to interpret the last part (<code>121/66</code>) which could mean a character selection with an offset from the start and length. The embedded schema could be overridden by explicitly stating which one to use within the URI. As an example, <code>medium.com/12475/elvis/0/learn-to-code/schema/42/121/187</code> could mean <code>&quot;use on-chain schema number 42&quot;</code> which could interpret the last part (<code>121/187</code>) as start offset and end offset instead of start &amp; length - resulting in the same selection as before. Even <a href="https://twitter.com/dwr/status/1544001073844731904">individual pages &amp; paragraphs of books</a> should be referencable in such a manner and could be composed of multiple separate posts - and this is just scratching the surface!</p>
<p>For big types of content (audio/video) the message could be broken down into chunks so that users can load only the message header and then depending on the schema used and the addressing within the content - only the necessary chunks could be requested.</p>
<!-- <div style="text-align: center;">
    <img src="images/meme_buffed_vs_weak_doge_persistent_uris_vs_nft_domains.jpg">
</div> -->
<!-- Persistent
human-readable
URIs that work
even if names
change ownership

Web3
Unstoppable
domains &
Ethereum Name
Service as NFTs

https://imgflip.com/memegenerator/Buff-Doge-vs-Cheems -->
<div style="break-before: page; page-break-before: always;"></div><div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>
<h1 id="messages"><a class="header" href="#messages">Messages</a></h1>
<p>The terms message/event/action/data/document/content are used interchangeably in this book and refer to any type of event/content a user might have generated - post/comment/reaction/etc.</p>
<!-- TODO: take stuff form the other messages.md doc

signal/noise ratio - message types & why we shouldn't wait for AI classification

- fallback/default presentation/rendering - how to display content if an application doesn't support a new activity type

tag type: disprove/correct - to combat misinformation & help crowdsource truth?

Why Headjack won't fall victim to stagnation and being stuck in time with this open standard and sort-of federation
https://signal.org/blog/the-ecosystem-is-moving/
- because messages will have default renderability
- because you'll always be able to click on items that your application cannot display properly and go to the application that produced them and see them properly

message type/format: price predictions with percentage possibilities, so that later reputations can be plotted based on the message type

tag type idea: prediction, and later with oracles credibility & track records could be automated



Announcement type

Pluggable visualization of different message types - configurable with styling


on editing messages:
https://twitter.com/VitalikButerin/status/1575890520403869696




https://en.wikipedia.org/wiki/Resource_Description_Framework
https://en.wikipedia.org/wiki/RDFa



https://spec.dsnp.org/DSNP/Announcements.html

- protobuf (protocol buffers) for message types?
- flatbuffers?
    https://en.wikipedia.org/wiki/FlatBuffers
- apache thrift? https://thrift.apache.org/
https://github.com/farcasterxyz/hub/issues/430
https://twitter.com/varunsrin/status/1617294606651260930


Farcaster Messages
https://hackmd.io/@farcasterxyz/ry2ff0lEj


Activity Streams formats?
https://spec.dsnp.org/ActivityContent/Overview.html



revisions of messages (edit/delete)
https://github.com/regular/ssb-revisions

New polling/info contribution ways
polling message type

TODO: look at Data models in ceramic!

“pit X vs Y”

shortcuts/links/references?

tombstone message
https://spec.dsnp.org/DSNP/Identity.html#retroactive-revocation-of-delegation

subreddits would be implemented by a special message type with a tag for the subreddit that people are posting into

updates to old post...
    - how would old unique URLs to the original posts get updated?
multiple edit events in parallel to the same original message? a fork? :|



update to post - as a diff, with different kinds of diff algos?

dislike button/protocol/spec? ⇒ reactions

https://en.wikipedia.org/wiki/Ontology_(information_science)
https://en.wikipedia.org/wiki/Web_Ontology_Language

https://en.wikipedia.org/wiki/Resource_Description_Framework

https://en.wikipedia.org/wiki/Microformat

https://en.wikipedia.org/wiki/Media_type

Post/rt/tag/mention/comment/quote/reply

concern: message standards...

https://schema.org/

https://en.wikipedia.org/wiki/Data_model

new types of messages get an on-chain ID so subscriptions are integer-based


messages contain their URIs and also a local timestamp - although that could be spoofed. It is however useful for ordering things in certain cases

also contain the current block height in addition to a unix timestamp

- not yet anchored content from one application can refer to other not yet anchored content from another application and then the anchors could be in such an order that an event references another event in a future block (because apps can share activity before it being anchored).
    - could this problem be ignored?




the <application_id>/<application_nonce> is embedded in a message that's being signed through an application/IDM such that it cannot suffer from a replay attack

- if a reply message has the URI to the original in non canonical form it would be harder for infrastructure to match those - it would have to translate the string URI to a number URI


Message type about binding something to a financial blockchain and making it illegal for the original creator to make a delete message - all exchange of ownership happens on the financial chain


- look into serialization formats & SSZ: https://twitter.com/varunsrin/status/1580710315175530496


message type: amplification - a type of proposal for others to follow someone as well
https://hackmd.io/IP-8snyMQfOGxV3LUjlJbA


https://ctzn.network/schemas
https://github.com/bluelinklabs/ctzn/tree/master/schemas



https://en.wikipedia.org/wiki/JSON-LD

constraints for messages - cannot be edited/deleted from another application? or it can?

https://atproto.com/guides/lexicon



open graph?
https://ogp.me/




-->
<div style="break-before: page; page-break-before: always;"></div><div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>
<h1 id="idms-preferences--graphs"><a class="header" href="#idms-preferences--graphs">IDMs, preferences &amp; graphs</a></h1>
<!--
how it gets managed by IDMs (so they will also touch IPFS?!)

public vs private
sections about public vs encrypted data?
also publicly announced vs non-announced but still unencrypted?



Apps should proactively talk to IDMs to let them know about user actions?

IDMs should provide a feed of all actions by a user - as a stream from which others can pick up from where they left off and continue forward - like a kafka topic

interest graph & how it works off-chain

TODO: change interest graph related things in other pages & pictures

- per account graph state? a materialized tree of the current state based on all prior events - both off-chain & on-chain?

- remove the focus on the interest graph - it will be off-chain!
    - also from all graphics!



ways to both use an IDM and still direct your personal perferences & private stuff to be handled by something of your choosing



1 of N requirement for keeping the interest graph intact & being able to recover it from somewhere


the graph could be moved on-chain if there are many MB/s of DB throughput (possibly sharding) but that would put a lot of strain on the 


myspace-like page  (or linktree-like) where you paint the picture of you - as a map or as whatever - but content shouldn't be owned by separate platforms


Connections can be multidimensional with explicit filtering & exclusion of content based on its type/tag or application that it originates from - all of which will also be represented by integers.




In Headjack all connections in the [interest graph](https://en.wikipedia.org/wiki/Interest_graph) are asymmetric and also visible & on-chain as it is geared towards [public discourse](https://www.quora.com/Will-the-future-of-social-graph-relationships-be-asymmetric-following-e-g-Quora-Twitter-or-symmetric-friending-e-g-Facebook/answer/David-O-Sacks) but private ones for a social graph can also be achieved through encryption - handled & stored by [IDMs](IDM.md) with greater trust assumptions. However, being public by default (as is the case with Twitter) and focusing on that aspect first greatly improves discoverability and the chances to bootstrap the network effect - propagation & reach are sought after. Identities will have their own customized landing pages off-chain through an IDM.



- `follows` (`array[integer]`) - list of accounts that it follows
    - `followers` (`array[integer]`) - a list of accounts that follow it (redundant - can be reconstructed by scanning all accounts - for faster queries of the other sort)

- Twitter: 400M users (220 MAU), average connections: 700
- 1.1 TB for arrays of arrays with 4 byte integers (the graph)
    - 2.2 TB (x2) if storing connections both ways for faster lookups (who do I follow & who follows me)
    - 4.4 TB (x2) if using long long int (8 bytes) - infinite indexes
- Metadata (pubkey, handle, description) per index would be O(1)
    - Less than the bytes required for 700 connections on average
- Realistic state size: ~20TB - database overhead & merkle roots
- The entire Twitter graph can be populated in a month with 1 MB/s of blockchain bandwidth



- private connections, posts & user data
    - see 4.2.2 Privacy (basically encrypted connections/actions and secrets shared/delegated to applications to operate on behalf of actor)
    even encrypted direct messaging could be implemented on top of this
    5.4.3 & 5.4.4
    https://unfinished.com/wp-content/uploads/dsnp_whitepaper.pdf
    - TODO: store off-chain?
    centralized connection graph is not incompatible with data pods as thought by in Solid, or Ceramic, etc.
        - can be stored & managed by ID managers
    - GDPR...
    https://matrix.org/~matthew/Response_to_-_Notes_on_privacy_and_data_collection_of_Matrix.pdf
    https://gitlab.com/libremonde-org/papers/research/privacy-matrix.org
    https://developer.litprotocol.com/docs/WhatIsLit/whatIsLitProtocol



muted keywords & preferences
https://twitter.com/AltcoinPsycho/status/1547203030185017344



- The importance of user data is on a spectrum with identity & connections being the most valuable - a clear example is [Substack](https://en.wikipedia.org/wiki/Substack) (basically [Medium](https://en.wikipedia.org/wiki/Medium_(website)) but you own the mailing list for your audience). The [interest graph](https://en.wikipedia.org/wiki/Interest_graph) is the subscription layer for information propagation - a forward-looking & ever-evolving data structure that gets reused over and over again each time content is created. It is the [essential crown jewel](https://twitter.com/balajis/status/1162539429484871681) that needs preservation - the global [pub-sub](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern). The data availability (DA - storage & retrievability) for identity & the interest graph needs to be guaranteed with cryptoeconomics on a permissionless ledger so anyone can build around it.


-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-storage--retrievability"><a class="header" href="#data-storage--retrievability">Data storage &amp; retrievability</a></h1>
<p>In this chapter we will see the different aspects of handling unlimited amounts of off-chain data:</p>
<ul>
<li><a href="store_and_retrieve.html#ingestion-and-transformation-of-blob-data">Ingestion and transformation of blob data</a></li>
<li><a href="store_and_retrieve.html#hierarchical-data-blobs--partial-fetches">Hierarchical data blobs &amp; partial fetches</a></li>
<li><a href="store_and_retrieve.html#direct-ipfs-connections--horizontal-scaling">Direct IPFS connections &amp; horizontal scaling</a></li>
<li><a href="store_and_retrieve.html#sharing-data-before-anchoring-it">Sharing data before anchoring it</a></li>
<li><a href="store_and_retrieve.html#how-to-retrieve-data-for-a-random-uri">How to retrieve data for a random URI</a></li>
</ul>
<h1 id="ingestion-and-transformation-of-blob-data"><a class="header" href="#ingestion-and-transformation-of-blob-data">Ingestion and transformation of blob data</a></h1>
<p>Off-chain blobs with data will be fetched, processed and stored immediately after they are published in more optimal database formats for content to be later directly served by application infrastructure. Most of the cryptography checks will be happening instantly during this process but the proofs don't need to be stored. Users will always be able to request proofs for any event at any time (&amp; cache them locally) because they can be regenerated on the fly as necessary.</p>
<h1 id="hierarchical-data-blobs--partial-fetches"><a class="header" href="#hierarchical-data-blobs--partial-fetches">Hierarchical data blobs &amp; partial fetches</a></h1>
<p>Blobs may be in a hierarchy such that the on-chain IPFS hash points only to the &quot;root&quot; blob that contains the header and the actual indexed data could be in child IPFS blobs (whose <a href="https://docs.ipfs.io/concepts/content-addressing/">IPFS CIDs</a> are contained in the root blob or header) so entities listening for events by specific accounts on Headjack may download only these headers and determine which &quot;leaf&quot; blobs they need to fetch for the data they are interested in (if any). Sparse bitsets &amp; <a href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filters</a> could be used to quickly scan for the presence of activity by specific accounts.</p>
<img src="images/root_child_blob_separation.png">
<h1 id="direct-ipfs-connections--horizontal-scaling"><a class="header" href="#direct-ipfs-connections--horizontal-scaling">Direct IPFS connections &amp; horizontal scaling</a></h1>
<p>Applications can advertise the multiaddress of their IPFS nodes on-chain so that each blob of content that gets published can be downloaded by others instantly by manually connecting with IPFS’s <a href="https://medium.com/pinata/speeding-up-ipfs-pinning-through-swarm-connections-b509b1471986">“swarm connect” functionality</a> - avoiding the use of the <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">DHT</a> for each new blob CID which may take tens of minutes. They can provide addresses to multiple IPFS nodes as a cluster for horizontal scaling and use <a href="https://ipfscluster.io/">Pinset orchestration</a> - designed for Automated data availability and redundancy.</p>
<p>Applications may choose not to use IPFS at all - what they must do is anchor their blobs with a Merkle root and provide some on-chain advertised means to retrieve the data (example: REST/RPC endpoints in their on-chain account). We expect that IPFS will be the lowest common denominator and will always be used no matter what other solutions are also available.</p>
<h1 id="sharing-data-before-anchoring-it"><a class="header" href="#sharing-data-before-anchoring-it">Sharing data before anchoring it</a></h1>
<p>Applications can talk to each other directly by using their on-chain advertised REST/RPC endpoints and may ask for the events &amp; messages that are not yet published by the other applications. This way they could display &quot;remote&quot; events locally while they are still in the &quot;mempool&quot; and allow their own users to interact with those events from other applications. This is possible because URIs are stable even before publication - see <a href="blobs_and_uris.html#stable-intra-blob-addressing-before-publishing">Stable intra-blob addressing before publishing</a>. High activity applications can interoperate and no longer be a slave to the block time. However:</p>
<ul>
<li>Applications should display events that are not yet anchored in the UI differently - especially if coming from another application.</li>
<li>Events that refer to each other but are from different applications and have not yet been anchored on-chain could end up committed in the wrong order (if one of the applications skips a few blocks and commits at a later one) - such that an event from the past is referring to an event from the future - breaking <a href="https://en.wikipedia.org/wiki/Referential_integrity">referential integrity</a>. However, <a href="messages.html">messages</a> have a timestamp field and could also have the current block height at the time of creation - useful for sorting.</li>
</ul>
<h1 id="how-to-retrieve-data-for-a-random-uri"><a class="header" href="#how-to-retrieve-data-for-a-random-uri">How to retrieve data for a random URI</a></h1>
<p>There are multiple options:</p>
<!-- TODO:
"The user account might be using an archival service for all their activity and they can point to that archival service on-chain in their account for others to retrieve their messages." ===> SHOULD BE ALSO ABLE TO ASK THE IDM OF THE USER !!! -->
<ul>
<li>The entire original blob with an <a href="https://docs.ipfs.io/concepts/content-addressing/">IPFS CID</a> might still be retrievable from the original application account that posted it or anyone else that has pinned the data.</li>
<li>The user account might be using an archival service for all their activity and they can point to that archival service on-chain in their account for others to retrieve their messages.</li>
<li>Other well-known players without a direct on-chain connection to the application/user in a URI could be asked if they have the content:
<ul>
<li>Infrastructure companies that do the heavy lifting for applications and store everything.</li>
<li>The analog of the <a href="https://en.wikipedia.org/wiki/Internet_Archive">Internet Archive</a> in this ecosystem that also stores everything.</li>
</ul>
</li>
<li>IPFS can be forked &amp; reused with the following change: instead of delivering content based on the <a href="https://docs.ipfs.tech/concepts/content-addressing/">CID</a> hash it can deliver the data + the necessary proofs based on Headjack URIs or their hash (they are unique) - any individual off-chain message that's been anchored would be retrievable as long as someone is hosting it in this p2p network (which needs bootstrapping - could be part of Headjack nodes). However, this won't be very performant due to the granular nature of individual messages with a URI and the use of a global <a href="https://en.wikipedia.org/wiki/Distributed_hash_table">DHT</a>.</li>
</ul>
<div style="text-align: center;">
    <img src="images/meme_we_are_not_the_same_addressability_vs_storage.jpg">
</div>
<!-- you deal with storage and retrievability of data
I address data
permanently
and allow for
storage and
location to
change
we are not the same
https://imgflip.com/memegenerator/342785297/Gus-Fring-we-are-not-the-same -->
<div style="break-before: page; page-break-before: always;"></div><div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>
<h1 id="blocks-state--proofs-oh-my"><a class="header" href="#blocks-state--proofs-oh-my">Blocks, state &amp; proofs, oh my!</a></h1>
<!-- 

Look at ethereum block & state structure
https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture
https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/


with small pieces of data the proofs for them could be orders of magnitude bigger - with Headjack storing them is not necessary as they can be derived from the original data blobs and the current state of the chain - a small core capable of producing the proofs for unlimited amounts of off-chain content

== there are 2 aspects when linking identity to a piece of data:

- merkle proof linking the data to a block
    - entities needs to keep either:
        - the full IPFS blobs and no merkle trees - can reconstruct a merkle proof for any piece of data at any time
        - or just the parts they care about + merkle proofs for each part to link them to a block
            - for multiple pieces of data can be optimized with merkle pollards and/or (sparse) multiproofs
    - if the state doesn't keep historical mapping of block numbers & identities to IPFS hashes:
        - there needs to be a merkle proof within the block
- merkle proofs linking identities to authorized services or keypairs at a specific block height




if the history of key rotations & revocations is not guaranteed, then data cannot be self-authenticating

events must be self-authenticating - and not requiring that the source (original creator) be always around to provide proofs for their authenticity.





- Graph with the proofs for a URI



TODO cache the merkle root & IPFS CID from blocks in the state?


if the blockchain doesn't store the full history of authorizations & keys forever then state merkle proofs will have to be saved at some point

    - Recursive merkleization of checkpointed L1 blocks/stateRoots so that anything can be referenced even with just the tip of the chain
    - https://en.wikipedia.org/wiki/Hash_array_mapped_trie
        CHAMP stands for Compressed Hash-Array Mapped Prefix-tree.
    - verkle trees

    optimizing merkle proofs
    https://medium.com/@jgm.orinoco/understanding-merkle-pollards-1547fc7efaa
    https://medium.com/@jgm.orinoco/understanding-sparse-merkle-multiproofs-9b9f049e8f08


# Block structure

- Transactions (token transfers)
- Registration/updates of applications
    - Sources for ephemeral content generated on the application - IPFS, Ceramic, HTTPS, etc.
- Blobs of data from each separate application
    - Follow/unfollow events
    - Update/delete account info/handle
    - Merkle root of all new content generated by the application
- Root hash of the state (connections, applications & accounts)



# What is in a block

- account actions
    - token transfers
    - IDM-like:
        - create new accounts without a keypair
        - binding & updating keypairs (changes require signature from the previous key)
        - list of application authorizations & revocations for accounts that it controls (each of which is just an integer pair - `56 => 661`)
    - Application-like:
        - content blob Merkle root
        - content blob IPFS CID
        - list of follow/unfollow actions for accounts (integers pairs - `67 => 27`)
        - Application-related info updates
            - IPFS node (cluster) address updates
            - keypair updates


- IDM batches
    - list of application authorizations & revocations (integers pairs - `56 => 661`)
    - follow/unfollow events (integers pairs - `67 => 27`)
    - keypair binding & changes (changes require signature from the previous key)
    - IDM-related info updates
- Application batches
    - follow/unfollow events (integers pairs - `67 => 27`)
    - content Merkle root
    - content blob IPFS CID 
    - Application-related info updates
        - IPFS node (cluster) address updates
        - keypair updates
- State root - the Merkle root for the latest materialized state

In reality a single account may play [all 3 roles](identity.md) - normal user, IDM & Application, so end users may even authorize applications & post content themselves as long as they have a keypair & the funds to pay for their direct on-chain transactions. The distinction here is to help paint the picture.

# Materialized state

For Headjack the state throughout history is much more important when compared to financial applications because there will be much more queries to prove things in the past (again and again) compared to just the present. Also, because 


TODO: does the state actually need to contain the historical mapping? not necessarily as third-party services could be doing that, but forcing full nodes to do it properly in the state & maintaining consensus would simplify the architecture of the rest


TODO: need examples & specifics for how big URI proofs would be


Make a graph with a block and txs and merkle roots




An account has the following properties:
- `ID` (`integer`) - unique on the blockchain, autoincrement, starting from 1
- `sig` - cryptographic address & signature
    - can be null ONLY if an `acm_id` is present
- `acm_id` (`integer`) - ACM ID - which [ACM](acm.md) can grant access to [applications](applications.md)
    - can be null ONLY if a `sig` is present

Other less important fields:

- `block_created` (`integer`) - in which block was the account first created

 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="throughput--scalability"><a class="header" href="#throughput--scalability">Throughput &amp; scalability</a></h1>
<p>Everyone claims to be scalable, but here we'll prove that Headjack can handle billions of accounts and anchor unlimited amounts of off-chain content tied to identity with simple napkin math.</p>
<ul>
<li><a href="numbers.html#how-big-is-a-headjack-transaction">How big is a Headjack transaction</a></li>
<li><a href="numbers.html#naive-scenario">Naive scenario</a></li>
<li><a href="numbers.html#realistic-scenario">Realistic scenario</a></li>
<li><a href="numbers.html#optimizations--scaling">Optimizations &amp; scaling</a></li>
<li><a href="numbers.html#state-growth">State growth</a></li>
<li><a href="numbers.html#off-chain-content">Off-chain content</a></li>
</ul>
<!-- measuring performance, throughput & latency is hard but here we will provide a simplistic view
https://a16zcrypto.com/why-blockchain-performance-is-hard-to-measure/ -->
<!-- We believe a credible path to billions and worldwide adoption is necessary as part of the story -->
<h1 id="how-big-is-a-headjack-transaction"><a class="header" href="#how-big-is-a-headjack-transaction">How big is a Headjack transaction</a></h1>
<p>Applications post anchors to off-chain content with an IPFS CID hash and a merkle root. IDMs also anchor off-chain content (mainly user preferences &amp; updates to social graph), but they also post authorizations to other accounts (applications) to post on behalf of users as integer pairs.</p>
<p>So the fields for a transaction by an application/IDM (which will be the majority) are:</p>
<ul>
<li>version: <code>4 bytes</code></li>
<li>signature: <a href="https://ethvigil.com/docs/eth_sign_example_code/#recovering-the-message-signer-in-the-smart-contract"><code>65 bytes</code></a></li>
<li>blob IPFS address: <a href="https://proto.school/anatomy-of-a-cid/01"><code>32 bytes</code></a></li>
<li>blob merkle root: <a href="https://www.mycryptopedia.com/merkle-tree-merkle-root-explained/"><code>32 bytes</code></a></li>
<li>nonce: <code>4 bytes</code> auto-increment integer associated with the account - to prevent reordering of anchored off-chain blobs (which would mess up internal addressing based on that nonce)</li>
<li>value: <code>4 bytes</code> amount of native token paid to validators for transaction inclusion</li>
</ul>
<p>So far that is <code>141 bytes</code> which almost every transaction by an application or IDM contains. IDMs also submit a list of authorizations (or revocations) as integer pairs. For example, 1000 accounts authorizing 15 different applications to post on their behalf would be 1000 integer pairs. Assuming 8 byte integers (up to 2^64) that would be 8 * 2 * 1000 = 16k bytes.</p>
<h1 id="naive-scenario"><a class="header" href="#naive-scenario">Naive scenario</a></h1>
<p>The initial version will target block bandwidth of up to 100 kb/s. This is not a problem for <a href="https://twitter.com/eshita/status/1546911451125649408"> ZK validiums</a> as there are already DA solutions that offer <a href="https://twitter.com/apolynya/status/1517137629334056960">10 mb/s or even much more</a>.</p>
<p>Assuming:</p>
<ul>
<li>1 MB block size &amp; 10 second block time (100 kb/s of block bandwidth)</li>
<li>1000 applications posting in every block</li>
<li>100 IDMs authorizing as much users as possible - filling the remaining block space</li>
<li>no on-chain actions such as keypair &amp; name changes, account creation &amp; direct interaction with the chain by end users</li>
</ul>
<p>We get:</p>
<ul>
<li>1100 actors (1000 applications + 100 IDMs) that post in every block at least <code>141</code> bytes for their transactions, which is <code>155100</code> bytes</li>
<li>the remaining <code>893476</code> bytes (1048576 (1MB) - 155100) can be filled with authorizations and since an authorization is <code>16</code> bytes (8 * 2) that would be 55842 authorizations/revocations every 10 seconds or 5584 authorizations/revocations per second</li>
<li>for 1 billion accounts that would be 0.557 authorizations/revocations per person per day which is actually quite good - people on average do way less <a href="https://en.wikipedia.org/wiki/Single_sign-on">single sign-ons</a> per day</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>completely different goals - comparing the 2 protocols just to put things into perspective</th><th>Headjack</th><th>Ethereum</th></tr></thead><tbody>
<tr><td>block size</td><td>1 MB</td><td><a href="https://etherscan.io/chart/blocksize"> ~80 kb </a></td></tr>
<tr><td>block time</td><td>10 seconds</td><td><a href="https://ycharts.com/indicators/ethereum_average_block_time"> ~13 seconds </a></td></tr>
<tr><td>blockchain bandwidth per second</td><td>100 kb/s (x16 more than Ethereum)</td><td>~6.15 kb/s</td></tr>
<tr><td>blockchain bandwidth per day</td><td>8640 mb/d</td><td>~528 mb/d</td></tr>
<tr><td>transactions/authorizations per second</td><td>5584 APS</td><td><a href="https://blockchair.com/ethereum/charts/transactions-per-second"> ~14 TPS </a></td></tr>
<tr><td>transactions/authorizations per day</td><td>482,457,600 APS</td><td>1,209,600</td></tr>
<tr><td>transactions/authorizations per person per day for 1 billion accounts</td><td>0.482 (x400 more than Ethereum)</td><td>0.0012096</td></tr>
</tbody></table>
</div><!-- Ethereum
- transactions per block: ~180
- single transaction size on average including calldata: 300-700 bytes -->
<h1 id="realistic-scenario"><a class="header" href="#realistic-scenario">Realistic scenario</a></h1>
<p>The naive scenario does not include on-chain actions for specific accounts such as:</p>
<ul>
<li>keypair changes (new pubkey (32 bytes) + signature (65 bytes) if there is an older key)</li>
<li>account creation (if done by an IDM then this is just a few bytes - no pubkey)</li>
<li>name registration &amp; ownership changes (see the <a href="handles.html">dedicated page</a> for more details)</li>
<li>updating account fields such as a URI pointing towards an off-chain account directory (which could point to archived posts) or pointing to another account index for such services</li>
<li>signed transactions by individual accounts that want to directly interact with the chain
<ul>
<li>authorizing an IDM, rotating keys, or even publishing off-chain content as an application</li>
</ul>
</li>
</ul>
<p>However, the realistic scenario will not be far from the naive because:</p>
<ul>
<li>Only a % of all accounts will have keypairs (even though 100% could) and will make just a few signed actions per year - leaving most block throughput for authorizations through IDMs.</li>
<li>Large % of accounts will rarely even be authorizing new applications - many people don't sign in to new services through <a href="https://en.wikipedia.org/wiki/Single_sign-on">SSO</a> every single day. There could also be 2 types of log-ins: passive (viewing only - nothing on-chain) and authorized (allowing services to post on behalf of users).</li>
<li>Many applications that don't generate a lot of off-chain activity will publish less often than on every block in order to minimize on-chain block space costs.</li>
<li>The chain throughput can be further optimized &amp; scaled by multiple orders of magnitude.</li>
</ul>
<h1 id="optimizations--scaling"><a class="header" href="#optimizations--scaling">Optimizations &amp; scaling</a></h1>
<ul>
<li>Throughput of 100 kb/s is just the start &amp; can easily go to 1-10 mb/s as a ZK rollup.</li>
<li>The chain &amp; state can be trivially sharded - there aren't problems such as fracturing liquidity or preventing composability because accounts don't care about each other - they mostly contain authorization block numbers &amp; keypair history.</li>
<li>Integer indexes that only need 4 bytes can be compressed/batched together - it'll take many years to go beyond 4 billion accounts so the actual throughput is <strong>2x</strong> of what is listed here.</li>
<li>A fee market can develop that tunes the cost of different actions so that actors don't just pay for on-chain bytes - the ways the system is used can be guided through incentives.</li>
<li>Other optimizations not listed here - this is just the starting point.</li>
</ul>
<h1 id="state-growth"><a class="header" href="#state-growth">State growth</a></h1>
<p>Headjack's main value proposition is keeping historical records of the sequence of authorizations, key changes &amp; off-chain content anchors and being able to generate proofs for any specific piece of off-chain content.</p>
<p>TODO: finish this</p>
<p>https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture</p>
<p>numbers - state - one difference from other cryptos is that this one is append-only and could be designed to be easier on memory access patterns</p>
<p>One difference with other blockchains is that accounts in Headjack are numbers and thus the state tree could be different.</p>
<p>on eth state growth:
https://twitter.com/SalomonCrypto/status/1587983584471633921
https://hackmd.io/@vbuterin/state_size_management</p>
<p>All on-chain changes just append data to one of the few attributes of:</p>
<ul>
<li>accounts:
<ul>
<li>public keys: a map of keys and block height integer ranges (non-overlapping)<!-- - could be a different data structure -->
</li>
<li>authorizations: a map of indexes and arrays of block height integer ranges</li>
<li>nonces: an array that maps autoincrement indexes to block numbers
<ul>
<li>appended only when publishing off-chain content (usually an application/IDM)</li>
</ul>
</li>
</ul>
</li>
<li>names:
<ul>
<li>owners: a map of owner indexes and block height integer ranges (non-overlapping)</li>
<li>nonces: an array that maps autoincrement indexes to account index &amp; nonce pairs
<ul>
<li>appended only when publishing off-chain content (usually an application/IDM)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TODO: should IPFS hashes &amp; merkle roots be saved in the state?
- no?</p>
<img src="images/account_name_state.png">
<!-- 

The growth of the chain and the state will differ by a few things:


One difference between Headjack and financial blockchains is that they don't force historical records into the state whereas that is the main value proposition of Headjack.



This is a solution that is provably possible and better and can only get better in time with further innovation and scaling


The goal is to avoid congestion and provide enough bandwidth in a predictable way for web scale



This could be a concern when Headjack takes over the world - if blocks are 10 mb once every 10 seconds the chain would grow by 86 gb/day. However, 

The processing of the state machine is minimal - orders of magnitude less complexity & compute compared to generalized smart contract platforms

The state growth will be slower than the blockchain growth because:

- an on-chain authorization is a pair of integers while only 1 integer goes into the state


goal: no congestion


a tiny core on which we have consensus can be used to cryptographically anchor & link unlimited amounts of data - the entire web - a few terabytes (tiny is relative - compared to the data) of materialized blockchain state including the absolute bare minimum of historic.

- state doesn't need to store the merkle roots & IPFS hashes - merkle proofs can contain block numbers & block hashes -->
<p>TODO: light clients? in addition to merkle proofs for inclusion of content they would need merkle proofs for the state of which applications a user has authorized to post on their behalf in a given block</p>
<h1 id="off-chain-content"><a class="header" href="#off-chain-content">Off-chain content</a></h1>
<p>There are no limits for off-chain content as it is all just anchored with merkle roots - it could be as high as hundreds of terabytes per second. There isn't a more minimal design that can link unbounded amounts of off-chain data to billions of identities that can change keys &amp; names and yet still provide the guarantees &amp; mental model simplicity of Headjack - it achieves consensus on the absolute bare minimum.</p>
<!-- validium

This design for a specialized blockchain can scale practically as much as necessary due to the compactness of service messages and the triviality of sharding the blockchain as there would be close to 0 cross-shard communication (`"X follows Y"` only affects `X`) and that is [provable with easy to grasp napkin math](numbers.md).

data availability guarantees don't need to be as strong as for finance - it won't be fatal to revert a few blocks of activity if data is unavailable -->
<!--
If handles are permanent to shards then their allocation to shards can be managed in the beacon chain and it can be consulted when following urls to content - so that the shard idx doesn't have to be in the urls
--><div style="break-before: page; page-break-before: always;"></div><h1 id="headjack-vs-the-competition"><a class="header" href="#headjack-vs-the-competition">Headjack vs the competition</a></h1>
<p>This chapter focuses on the disadvantages of some of the more high-profile competing solutions in the space. Most of the issues are solved in Headjack due to its <a href="principles.html">guiding principles &amp; design goals</a>. This page doesn't list any of their positives as it would be too long (so not exhaustive by any means) but many of them have served as an inspiration for Headjack in one way or another.</p>
<!-- > "In order to cure, you must first understand." - [Random scientist, 28 Days Later (2002)](https://www.quotes.net/mquote/962715) -->
<!-- Corrections for any inaccuracies are welcome! -->
<!-- If Bluesky, Farcaster and DSNP had a baby with some special MKUltra spice it would be Headjack -->
<ul>
<li><a href="competition.html#comparison-table">Comparison table</a></li>
<li><a href="competition.html#what-other-projects-get-wrong">What other projects get wrong</a></li>
<li><a href="competition.html#farcaster">Farcaster</a></li>
<li><a href="competition.html#dsnp-frequency--project-liberty">DSNP, Frequency &amp; Project Liberty</a></li>
<li><a href="competition.html#tbd">TBD</a></li>
<li><a href="competition.html#cyberconnect">CyberConnect</a></li>
<li><a href="competition.html#deso">DeSo</a></li>
<li><a href="competition.html#others">Others</a></li>
</ul>
<h1 id="comparison-table"><a class="header" href="#comparison-table">Comparison table</a></h1>
<p>Some of this is a subjective estimation - many of the claims lack official sources.</p>
<!-- <iframe src="competition_table.html" title="Comparison table"
style="width:100%; height:1200px"
></iframe>

!!!
https://stackoverflow.com/questions/3934271/horizontal-scrollbar-on-top-and-bottom-of-table

https://stackoverflow.com/questions/16660559/difference-between-iframe-embed-and-object-elements

https://stackoverflow.com/a/31513163

<object data="competition_table.html" style="width:100%; height:1200px"></object>

<iframe src="competition_table.html" onload='javascript:(function(o){o.style.height=(o.contentWindow.document.body.scrollHeight+30)+"px";}(this));' style="height:200px;width:100%;border:none;overflow:hidden;"></iframe> -->
<div>
<style type="text/css" scoped>
    .competition_comparison td {
        padding: 0;
        margin: 0;
        width: 12%;
        color: black;
        font-size: 12px;
        text-align: center;
        background-color:white;
    }
    .competition_comparison td a:link {
        color: #0000EE;
        text-decoration: underline;
    }
    .competition_comparison td a:visited {
        color: #551A8B;
        text-decoration: underline;
    }
</style>
<table class="competition_comparison" style="width:120%;">
<tr>
    <td style="width:16%"></td>
    <td><b>Headjack</b></td>
    <td><b><a href="competition.html#farcaster">Farcaster</a></b></td>
    <!-- https://www.farcaster.xyz/ -->
    <td><b><a href="https://www.dsnp.org/">DSNP</a> & <a href="https://www.frequency.xyz/">Frequency</a></b></td>
    <td><b><a href="https://en.wikipedia.org/wiki/Bluesky_(protocol)">Bluesky</a> & <a href="https://atproto.com/">AT Protocol</a></b></td>
    <td><b><a href="https://developer.tbd.website/projects/web5/">TBD web5</a><br/><a href="https://docs.google.com/presentation/d/1SaHGyY9TjPg4a0VNLCsfchoVG1yU3ffTDsPRcU99H1E">slides</a> & <a href="https://twitter.com/namcios/status/1535302090360250368">tweet</a></b></td>
    <td><b><a href="https://ceramic.network/">Ceramic</a> & <a href="https://cyberconnect.me/">CyberConnect</a></b></td>
    <td><b><a href="https://lens.xyz/">Lens<br/>Protocol</a></b></td>
</tr>
<tr>
    <td style="background-color:grey" colspan="8" height=25px><b>blockchain-related properties</b></td>
</tr>
<tr>
    <td><b>Scalability & potential scope</b></td> 
    <td style="background-color:green">can handle billions of users (<a href="numbers.html">proof</a>) & underpin the entire web</td>
    <td style="background-color:lime">perhaps up to ~10 million - could move to its own rollup</td>
    <td style="background-color:yellow">perhaps up to a few million  graph changes are on-chain</td>
    <td style="background-color:green">centralized consortium of servers</td>
    <td style="background-color:yellow">perhaps up to<br>a few million - lots of reliance on IPFS, DHTs, hashes & keys</td>
    <td style="background-color:yellow">perhaps up to<br>a few million - lots of reliance on IPFS, DHTs, hashes & keys</td>
    <td style="background-color:red">actions are on-chain as NFTs (follow, post's hash) - even a dedicated EVM chain will be futile</td>
</tr>
<tr>
    <td><b>Users paying for TX fees & linking identity to financial accounts by default</b></td>
    <td style="background-color:green">all blockchain costs are paid for by services by default</td>
    <td style="background-color:yellow">Ethereum L1 costs initially planned for subsidy by services</td>
    <td style="background-color:green">all blockchain costs are paid for by services by default</td>
    <td style="background-color:green">centralized consortium of servers - no TXs</td>
    <td style="background-color:lime">the anchors (on-chain Merkle roots) get batched with others</td>
    <td style="background-color:yellow">only the stream anchors to Ethereum L1 have to be paid for occasionally</td>
    <td style="background-color:red">yes</td>
</tr>
<tr>
    <td><b>Blockchain TX fee stability & predictability</b></td>
    <td style="background-color:green"><a href="numbers.html">as scalable as necessary => no congestion</a></td>
    <td style="background-color:red">Ethereum L1 - may need to migrate to its own rollup in the future</td>
    <td style="background-color:lime"><a href="https://forums.projectliberty.io/t/05-what-is-capacity-frequency-economics-part-1/248">their notion of capacity</a> is probably good enough</td>
    <td style="background-color:green">centralized consortium of servers - no TXs</td>
    <td style="background-color:lime">Bitcoin TX fees are low due to low economic activity</td>
    <td style="background-color:red">Ethereum L1 for stream anchors</td>
    <td style="background-color:lime">Polygon PoS</td>
</tr>
<tr>
    <td><b>Block time for anchoring key operations</b></td>
    <td style="background-color:green">Ethereum ZK validium with multiple blocks in one L1 slot</td>
    <td style="background-color:lime">Ethereum</td>
    <td style="background-color:lime">Polkadot</td>
    <td style="background-color:green">centralized consortium of servers</td>
    <td style="background-color:red">Bitcoin</td>
    <td style="background-color:yellow">Ethereum, but the anchors are occasional</td>
    <td style="background-color:green">Polygon PoS</td>
</tr>
<tr>
    <td><b>Time to finality for key operations</b></td>
    <td style="background-color:yellow">Ethereum</td>
    <td style="background-color:yellow">Ethereum</td>
    <td style="background-color:lime">Polkadot</td>
    <td style="background-color:green">centralized consortium of servers</td>
    <td style="background-color:red">Bitcoin</td>
    <td style="background-color:yellow">Ethereum</td>
    <td style="background-color:lime">Polygon PoS</td>
</tr>
<tr>
    <td><b>Contains a name registry for easy discoverability & can replace DNS</b></td>
    <td style="background-color:green">yes - & tightly integrated with addressability - URIs aren't broken <a href="names_and_paths.html">even if names change ownership</a></td>
    <td style="background-color:green">yes, also works with ENS</td>
    <td style="background-color:red">no, but might introduce it</td>
    <td style="background-color:red">no - uses <a href="https://atproto.com/guides/identity">email-like usernames</a> resolved with <a href="https://webfinger.net/">Webfinger</a> to a <a href="https://www.w3.org/TR/did-core/">DID</a> & relies on DNS (centralized)</td>
    <td style="background-color:red">no</td>
    <td style="background-color:red">no, maybe works with ENS</td>
    <td style="background-color:red">no, maybe works with ENS</td>
</tr>
<tr>
    <td><b>Decentralization for the most important parts (keys & registries)</b></td>
    <td style="background-color:lime">Ethereum ZK validium with external data availability (validium) - <a href="https://www.layrlabs.com/products">EigenDA</a>?</td>
    <td style="background-color:green">Ethereum</td>
    <td style="background-color:lime">Polkadot - not big enough set of validators</td>
    <td style="background-color:red">centralized consortium of servers</td>
    <td style="background-color:yellow">Bitcoin, but DID operations are only anchored</td>
    <td style="background-color:yellow">Ethereum, but only the stream anchors go there</td>
    <td style="background-color:yellow">Polygon PoS</td>
</tr>
<tr>
    <td><b>Incentive layer & data availability for the most important (keys & registries)</b></td>
    <td style="background-color:green">Ethereum ZK Validium</td>
    <td style="background-color:green">Ethereum</td>
    <td style="background-color:green">Polkadot</td>
    <td style="background-color:green">centralized consortium of servers</td>
    <td style="background-color:red">DID operations are stored in a network on IPFS <a href="https://github.com/decentralized-identity/ion/blob/master/docs/Q-and-A.md#q-what-are-the-availability-guarantees-of-ion">without incentives</a></td>
    <td style="background-color:red">the actual streams are in a network w/o incentives</td>
    <td style="background-color:green">Polygon PoS</td>
</tr>
<tr>
    <td style="background-color:grey" colspan="8" height=25px><b>Data availability, storage, retrievability & addressing</b></td>
</tr>
<tr>
    <td><b>Human-readable & persistent URIs for data without any hashes</b></td>
    <td style="background-color:green"><a href="names_and_paths.html"><img src="images/meme_yes_chad_green.png"/></a></td>
    <td style="background-color:red">URIs full of <a href="https://github.com/farcasterxyz/protocol/pull/1/files">hashes</a> (probably)</td>
    <td style="background-color:red">URIs full of <a href="https://spec.dsnp.org/DSNP/Identifiers.html?highlight=uri#dsnp-content-uri">hashes</a></td>
    <td style="background-color:red">URIs full of <a href="https://atproto.com/guides/data-repos#data-layout">hashes</a> - <a href="https://github.com/multiformats/cid">CIDs</a> for IPLD objects</td>
    <td style="background-color:red">URIs full of hashes (probably)</td>
    <td style="background-color:red">URIs full of <a href="https://cerscan.com/testnet-clay/stream/kjzl6cwe1jw1474gby1buhqw8xbnvfmfphpvrs0n01n6jls9kvdx7hu41w0sp1m">hashes</a></td>
    <td style="background-color:red">URIs full of <a href="https://lenster.xyz/posts/0x05-0x04f4">hashes</a></td>
</tr>
<tr>
    <td><b>Multiple ways to ask for a URI's document<br/>(in addition to caches/archives)</b></td>
    <td style="background-color:green;text-align:left;"><a href="store_and_retrieve.html#how-to-retrieve-data-for-a-random-uri">&nbsp;multiple ways:</a><br/>&nbsp;<b>1)</b> user's <a href="IDM.html">IDM</a><br/>&nbsp;<b>2)</b> <u><b>source app identifiable from the URI</b></u><br/>&nbsp;<b>3)</b> <u><b>IPFS blob from the block</b></u><br/>&nbsp;<b>4)</b> p2p network</td>
    <td style="background-color:yellow;text-align:left;">&nbsp;<b>1)</b> user's Hub<br/>&nbsp;<b>2)</b> p2p network</td>
    <td style="background-color:red;">URIs contain only <a href="https://spec.dsnp.org/DSNP/Identifiers.html?highlight=uri#dsnp-content-uri">user id & content hash</a> without user Hubs (yet) & p2p network</td>
    <td style="background-color:yellow;text-align:left;">&nbsp;<b>1)</b> user's <a href="https://atproto.com/guides/data-repos">PDR</a><br/>&nbsp;<b>2)</b> maybe p2p network with the content <a href="https://atproto.com/guides/data-repos#data-layout">CID</a></td>
    <td style="background-color:red;text-align:left;">&nbsp;probably<br/>&nbsp;<b>1)</b> user's <a href="https://github.com/TBD54566975/dwn-sdk-js">DWN</a><br/>&nbsp;<b>2)</b> p2p network</td>
    <td style="background-color:red;">only p2p network as Ceramic streams are an abstraction over IPFS</td>
    <td style="background-color:red;">unsure - maybe the on-chain NFT post</td>
</tr>
<tr>
    <td><b>Big reliance on a p2p network for delivering fine-grained messages</b></td>
    <td style="background-color:green">using a p2p network for specific URIs is the last resort</td>
    <td style="background-color:red">using a gossip-based pubsub protocol between peers & Hubs</td>
    <td style="background-color:grey">not sure: their URIs contain only <a href="https://spec.dsnp.org/DSNP/Identifiers.html?highlight=uri#dsnp-content-uri">user id & content hash</a> but they don't have an IDM/Hub/ PDR/DWN as a concept (yet)</td>
    <td style="background-color:green">no - talk directly to a user's <a href="https://atproto.com/guides/data-repos">PDR</a></td>
    <td style="background-color:grey">not sure: perhaps could directly talk to a user's DWN</td>
    <td style="background-color:red">yes - IPFS, Ceramic Network & global DHTs</td>
    <td style="background-color:grey"></td>
</tr>
<tr>
    <td><b>Push (broadcast) vs pull (polling) for fetching new content</b></td>
    <td style="background-color:green">both - event batches are broadcasted & new/individual documents can be requested</td>
    <td style="background-color:red">pull only - requires polling a user's Hub for anything new</td>
    <td style="background-color:green">both - event batches are broadcasted & new/individual documents can be requested</td>
    <td style="background-color:red">pull only - requires polling a user's <a href="https://atproto.com/guides/data-repos">PDR</a> for anything new</td><td style="background-color:red">pull only - requires polling a user's <a href="https://github.com/TBD54566975/dwn-sdk-js">DWN</a> for anything new</td>
    <td style="background-color:green">both - events are broadcasted & new/individual documents can be requested</td>
    <td style="background-color:grey"></td>
</tr>
<tr>
    <td><b>Self-authenticating documents</b></td>
    <td style="background-color:green">proofs are validated by the blockchain</td>
    <td style="background-color:yellow">need to talk to Ethereum <b>AND</b> the host-certified user directory which can disappear OR change</td>
    <td style="background-color:yellow">merkle roots <a href="https://github.com/LibertyDSNP/frequency/issues/105">not present</a></td>
    <td style="background-color:green">proofs are validated by the transparency log</td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
</tr>
<tr>
    <td style="background-color:grey" colspan="8" height=25px><b>Ease of use for developers & users</b></td>
</tr>
<tr>
    <td><b>Can leverage existing Web2 authenticating infrastructure</b></td>
    <td style="background-color:green">Can leverage all existing OAuth / SAML code</td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
</tr>
<tr>
    <td><b>Easy to work with mental model vs high cognitive load & complexity</b></td>
    <td style="background-color:lime">A bit more complexity compared to Web2</td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
</tr>
<tr>
    <td><b>Can use "custodial" hosted services while retaining ultimate control</b></td>
    <td style="background-color:green"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
</tr>
<tr>
    <td><b>Ease of indexing & building responsive UI</b></td>
    <td style="background-color:green">can be as performant as Web2 and not constrained by block time</td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
    <td style="background-color:grey"></td>
</tr>
<!-- <tr>
    <td>-</td>
    <td style="background-color:green">-</td>
    <td style="background-color:grey">-</td>
    <td style="background-color:grey">-</td>
    <td style="background-color:grey">-</td>
    <td style="background-color:grey">-</td>
    <td style="background-color:grey">-</td>
    <td style="background-color:grey">-</td>
</tr> -->
</table>
</div>
<p><a id="footnote-1-ref" href="competition.html#footnote-1">[1]</a>
<a id="footnote-2-ref" href="competition.html#footnote-2">[2]</a></p>
<div id="footnote-1">
   1. X. <a href="competition.html#footnote-1-ref">&#8617;</a> 
</div>
<div id="footnote-2">
   2. X. <a href="competition.html#footnote-2-ref">&#8617;</a>
</div>
<!--


avoiding signatures by default - only hashing - much faster
asymmetric cryptography is SLOW
https://medium.com/logos-network/benchmarking-hash-and-signature-algorithms-6079735ce05
https://crypto.stackexchange.com/questions/38043/hmac-vs-rsa-speed

bloat because of individual signatures - versus computable hashes that don't need to be stored

DA is very important for DID resolution - if there's no guaranteed DA - there's no guaranteed resolution.


authentic timestamps?

how easy it is to build aggregators for the entire public web?

are applications bottlenecked by the personal data repository of a user? yes in the case of farcaster & bluesky



Order of data determined by the URI as a line

Value capture potential as a line

discoverability

Storage agnostic or opinionated in table

protocol-first vs app-first

https://news.ycombinator.com/item?id=33264860
about bluesky
4. I wonder what the team will do for authentication and authorization? Will they go the ACL route? (In which case, are they going to include Solid-style client identity, in the ACLs?) Will they go the capabilities route? (UCANs / zCaps). This is the genuine hard part.



Having the app id and doing batch commitments simplifies routing and aids self-authenticity for documents

names are worthless if they aren't in URIs pointing to documents

The winner take all singleton is the easiest mentally

having everything from a user in a tree with a root hash - easier replication
https://atproto.com/guides/data-repos

-->
<div style="text-align: center;">
    <img src="images/meme_15_competing_standards.png">
</div>
<!-- Headjack is the [15th and final](https://xkcd.com/927/) standard for decentralized identity. -->
<h1 id="what-other-projects-get-wrong"><a class="header" href="#what-other-projects-get-wrong">What other projects get wrong</a></h1>
<p>A list of problems with the contenders in the decentralized identity/media space:</p>
<ul>
<li>No credible path to <a href="principles.html#web-scale-blockspace--the-unix-philosophy">web-scale</a> - some will hit a wall even at 1 million users. Most are vague around their scalability &amp; data structures and don't put it <a href="numbers.html">front and center</a> - obfuscating the most important bit. Instead of focusing on NFTs &amp; developer APIs, start with the data and work up from that.<!-- > "It is the mark of a charlatan to explain a simple concept in a complex way." - [@naval](https://twitter.com/naval/status/752796426208325632) -->
</li>
</ul>
<!-- Fake it till you make it is not a viable strategy with the wrong foundation. -->
<ul>
<li>
<p>Complexity &amp; lack of clarity - distributed systems engineers should easily figure out how they work &amp; what the limitations are. Why build on something that others are probably having a hard time understanding as well and may not be around in the future?</p>
<blockquote>
<p>&quot;Developers care about risk.&quot; - <a href="https://haseebq.com/why-decentralization-isnt-as-important-as-you-think/">Haseeb</a></p>
</blockquote>
<blockquote>
<p>&quot;For the simplicity on this side of complexity, I wouldn't give you a fig. But for the simplicity on the other side of complexity, for that I would give you anything I have.&quot; - <a href="https://www.goodreads.com/quotes/44564-for-the-simplicity-on-this-side-of-complexity-i-wouldn-t">Oliver Wendell Holmes</a></p>
</blockquote>
</li>
<li>
<p>Too financialized &amp; trying to do too much - profiles &amp; posts as NFTs, microtransactions, marketplaces, fan coins, tipping, content creator incentives.</p>
<blockquote>
<p>&quot;However, a downside I’ve observed in social networks where content is monetized is that user behavior becomes transparently driven by monetary incentives in ways that feel less genuine. This applies to influencer culture on Instagram as well, but cryptocurrency social networks bake it in from the start.&quot; - <a href="https://medium.com/decentralized-web/blockchain-social-networks-c941fb337970">Jay Gerber</a></p>
</blockquote>
<blockquote>
<p>&quot;The question remains: is the future of social media truly intrinsically linked to NFTs or is it a red herring?&quot; - <a href="https://wrongalot.substack.com/p/the-next-big-crypto-narrative">@mattigags</a></p>
</blockquote>
</li>
<li>
<p>Users shouldn't need to use a token, use a wallet, or self-host to benefit from decentralized identity &amp; an open social graph. Most people will always use custodial services.</p>
<blockquote>
<p>&quot;People don’t want to run their own servers, and never will.&quot; - <a href="https://moxie.org/2022/01/07/web3-first-impressions.html">Moxie</a></p>
</blockquote>
</li>
<li>
<p>Linking online identity to public financial accounts on Ethereum/Solana/etc will have unintended consequences - a bad default.</p>
</li>
<li>
<p>Federated ones lack <a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">logical centralization</a> which leads to fragmentation and <a href="https://github.com/mastodon/mastodon/issues/9529">no discoverability</a>.</p>
</li>
<li>
<p>Some are solving just identity &amp; the graph - without easy &amp; persistent <a href="addressing.html">content addressing</a>.</p>
</li>
<li>
<p>Social media is about aggregated views at scale - not p2p and direct comms.</p>
<blockquote>
<p>&quot;The emphasis of a social network is on &quot;propagation&quot; aka, propaganda.&quot; - <a href="https://news.ycombinator.com/item?id=25735773">didibus</a></p>
</blockquote>
</li>
<li>
<p>Some use chains such as Ethereum for <a href="https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274">logical centralization</a> &amp; store vector commitments (Merkle roots) for events around <a href="https://blog.ceramic.network/key-revocation-in-self-certifying-protocols/">key management</a> (rotations, authorizations, sessions &amp; revocations) but the data availability problem for whatever is committed is unsolved.</p>
<ul>
<li>The complexity is not encapsulated - there are many open questions, edge cases &amp; failure scenarios and it would inevitably lead to assumptions &amp; trust.</li>
</ul>
<!-- - Many focus just on the latest keypairs and don't sequence the signed actions throughout time  - much harder to prove that content generated with an older keypair was indeed legitimate at the time of creation and generated back in time instead of fraudulently constructed later on if the keypair is compromised. -->
<ul>
<li>Some anchor to Bitcoin but the time to finality matters a lot for UX - 10-minute block times with probabilistic finality is horrendous.</li>
</ul>
</li>
<li>
<p>Some lack an economic incentive layer.</p>
<blockquote>
<p>&quot;Show me the incentive and I will show you the outcome.&quot; - <a href="https://quotefancy.com/quote/1561882/Charlie-Munger-Show-me-the-incentive-and-I-will-show-you-the-outcome">Charlie Munger</a></p>
</blockquote>
</li>
</ul>
<!-- What you don't want is for these identifiers to be fractured between many platforms with different standards & formats. -->
<h1 id="farcaster"><a class="header" href="#farcaster"><a href="https://www.farcaster.xyz/">Farcaster</a></a></h1>
<!--
https://farcasterxyz.notion.site/farcasterxyz/Farcaster-v2-43b105e4699847518b1d89996c20d564
-->
<!-- 

farcaster is a specific social networking protocol that is trying to also handle consistency & conflicts - like not allowing double liking of a post by a specific user, etc.

Their product-led protocol development strategy means they need to chase product-like targets when designing a foundational protocol. Following [Goodhart's law](https://en.wikipedia.org/wiki/Goodhart%27s_law), when a measure becomes a target, it ceases to be a good measure.

!!!!!

Farcaster can be entirely rebuilt on top of Headjack but not everything that Headjack enables can be built on top of Farcaster.

product-led protocol development
https://chapterone.substack.com/p/farcaster-the-new-crypto-gtm
https://twitter.com/TziokasV/status/1581688157204254720
https://chapterone.substack.com/i/77871905/product-led-protocol-development
No - product-led protocol development is rarely the best way forward if you get the foundations wrong - iterating out of a local maximum may prove impossible and kill the product. Once there is a yet-unsustainable product that requries money, there is also a timer that is ticking.

With Farcaster, content is directory-certified and cannot be fully self-authenticating because if the directory to which the on-chain account points to goes away - so does the credibility for any piece of data by that account - no way to cache proofs. Furthermore, directories can be tampered with and currently it's up to the p2p network to keep track if any malicious changes happen



farcaster - their model can work even without the p2p nodes - aggregators can be built that talk directly to host directories

farcaster can be built on top of Headjack but not everything that can be built on Headjack can on Farcaster

Farcaster is the best team in the space.


-->
<p>Their architecture: <a href="https://github.com/farcasterxyz/protocol">link</a>. The account registry is on a blockchain and everything else is off-chain.</p>
<ul>
<li>
<p>Registry on Ethereum L1 - for new accounts, name/host changes &amp; key management.</p>
<ul>
<li>No plans on moving to an L2 or their own chain. Also, state rent could eventually be introduced to Ethereum which would lead to further costs &amp; complexity.</li>
</ul>
</li>
<li>
<p>Keypairs &amp; wallets required - harder mass adoption. Authorizations still <a href="https://github.com/farcasterxyz/protocol#45-signer-authorizations">require a signature from the root key</a>.</p>
</li>
<li>
<p>Revocations invalidate all prior activity from a delegate:</p>
<blockquote>
<p>&quot;Unfortunately, this means that all messages signed by that signer will be lost since we cannot tell which ones were signed by the attacker.&quot; - <a href="https://github.com/farcasterxyz/protocol#71-signer-compromise">source</a></p>
</blockquote>
<ul>
<li><a href="https://github.com/farcasterxyz/protocol#46-root-signer-revocations">Root signer revocations</a> are even more impactful.</li>
</ul>
</li>
</ul>
<!-- - Cast timestamps are self-reported and can be manipulated - no true cryptographic total ordering - which leads to a lot of complexity in the node software. Not sure what happens to old casts that were signed with obsolete keypairs and how the history of keys is handled. -->
<!-- message ordering, timestamps & authenticity can be manipulated which requires more logic in the software to keep track of previous hashes
https://github.com/farcasterxyz/protocol#message-ordering -->
<ul>
<li>The <a href="https://github.com/farcasterxyz/protocol#5-peering">p2p network</a>'s ability to scale by passing around granular casts is questionable - they are already discussing possible flooding and nodes having to shadow ban and flag accounts based on behavior.</li>
</ul>
<!-- TODO: problem with farcaster - you cannot save content from others forever with authentic proofs if the person removes completely their history of key changes & content signatures. Correct? -->
<!-- Directly polling accounts & their hosts for new events is more scalable but has tradeoffs compared to broadcasting messages & ingesting them into DBs & indexes (pull vs push). -->
<ul>
<li>
<p>Focus is on <a href="https://github.com/farcasterxyz/protocol#47-sharding">partial views of the network</a> as opposed to mass scale aggregation &amp; indexing - although that could easily be implemented.</p>
</li>
<li>
<p><a href="https://github.com/farcasterxyz/protocol/pull/1/files">Cast URIs</a> will look something like <code>farcaster://id:8789213729/cast:0xf00b4r</code> which is less readable than what Headjack will be offering with <a href="addressing.html">its addressing</a>.</p>
</li>
</ul>
<p>Overall good intuition about the concept of <a href="https://www.varunsrinivasan.com/2022/01/11/sufficient-decentralization-for-social-networks">sufficient decentralization</a> (putting only what is absolutely necessary on a blockchain) but the p2p node implementation takes on too much <a href="https://github.com/farcasterxyz/protocol#7-security-considerations">responsibility, complexity &amp; assumptions</a> (consensus, CRDTs, trees, ordering, flooding &amp; replay attacks, etc.) and is lacking in other areas.</p>
<!-- perhaps the best product team in the space and a good attempt to bootstrap a community -->
<h1 id="dsnp-frequency--project-liberty"><a class="header" href="#dsnp-frequency--project-liberty"><a href="https://www.dsnp.org/">DSNP</a>, <a href="https://www.frequency.xyz/">Frequency</a> &amp; <a href="https://www.projectliberty.io/">Project Liberty</a></a></h1>
<p>Frequency (a Polkadot parachain) is the first implementation of DSNP (Decentralized Social Networking Protocol - <a href="https://github.com/LibertyDSNP/papers/blob/main/whitepaper/dsnp_whitepaper.pdf">whitepaper</a>) as a standalone blockchain and has had the most influence over Headjack's design but the two have diverged in some key respects - the biggest of which are scalability, content addressability, UX &amp; choosing Polkadot. Some of the problems with them:</p>
<ul>
<li>
<p>No names within the project - just integer IDs for accounts. Content addressing URIs are based on hashes without connection to the batch # / service that published it - example: <code>dsnp://78187493520/0x1234567890abcdef0123456789abcdef0123456789abcdef</code> (<a href="https://spec.dsnp.org/DSNP/Identifiers.html#dsnp-content-uri">source</a>). Addressing content is much worse compared to Headjack's <a href="addressing.html">human-readable &amp; persistent URIs</a>.</p>
</li>
<li>
<p>Delegating applications to be able to post on behalf of users (analogous to authorization in Headjack) happens on-chain but requires a signature from the user (bulky - limiting throughput). New applications (&amp; revocation) require the user to have access to their keys. Hierarchical delegation would allow for UX comparable to Web2 and would even allow for users without keypairs at all but DSNP doesn't have that - Headjack does. <!-- https://discord.com/channels/969001918460469250/969308056208961606/996417552962043924 --></p>
</li>
<li>
<p><a href="https://philanthropynewsdigest.org/news/project-liberty-launched-with-100-million-from-frank-mccourt">100m$ of funding</a> (so far) from just 1 person - <a href="https://www.youtube.com/watch?v=xgPZnOulBCE">Frank McCourt</a> - no other capital &amp; connections to reputable investors &amp; influencers from either the crypto or tech space - generating hype &amp; booting up the network effect might be very hard. They've been around since 2019.</p>
</li>
</ul>
<!-- 
# bluesky

deleting an old post requires re-merkleization of the tree



hash-based intra-PDR addressing - could get very bloated

if a user's PDR goes away all cached documents are no longer linkable to their identity

- **Consortium** of nodes & a transparency log manage the DID registry.
    - Centralization point (not just [logical](https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274)) - users can be kicked off.
    - This should have been a credibly neutral & self-sustaining blockchain.

- Requires the use of keypairs which is worse UX compared to Headjack and would hinder mass adoption - although they do talk about [custodial solutions](https://github.com/bluesky-social/adx/blob/main/docs/#root-private-key-management).

- When users post content they update their Personal Data Repositories managed by their Personal Data Servers (PDS) which play somewhat similar roles to [Farcaster](#farcaster)'s managed hosts and Headjack's [IDMs](IDM.md).

- Users can lose their interest graph if the PDS they are using loses their data.

- The Personal Data Repositories would be a lot less compact than Headjack because accounts and links between them are not simple integers and every piece of data and relationship comes along with a signature.

Overall a solid effort and could work - some similarities to [Farcaster](#farcaster) but the DID registry is centralized by a consortium and the usernames are email-like (DNS - centralization point) instead of handled by the DID registry. Neither solution anchors content like Headjack does. -->
<h1 id="tbd"><a class="header" href="#tbd"><a href="https://www.tbd.website/">TBD</a></a></h1>
<p>Jack Dorsey's new <a href="images/meme_web5.jpg">&quot;web5&quot;</a> project - <a href="https://docs.google.com/presentation/d/1SaHGyY9TjPg4a0VNLCsfchoVG1yU3ffTDsPRcU99H1E">slides</a>, <a href="https://twitter.com/namcios/status/1535302090360250368">announcement</a>.</p>
<ul>
<li>Only anchors DID events to Bitcoin with vector commitments (Merkle roots) using <a href="https://github.com/decentralized-identity/ion">ION</a> &amp; the <a href="https://medium.com/decentralized-identity/the-sidetree-scalable-dpki-for-decentralized-identity-1a9105dfbb58">Sidetree</a> protocol.
<ul>
<li>10-minute block times with probabilistic finality. Factor in the loading times for the anchored content around key management that's on IPFS - not great at all if you want to log in/authorize a service or revoke access quickly.</li>
</ul>
</li>
</ul>
<!-- - The ION DID network is [not incentivized](https://github.com/decentralized-identity/ion/blob/master/docs/Q-and-A.md#q-what-are-the-availability-guarantees-of-ion) (just like IPFS) and the anchored content around key management, rotations & revocations depends on the current cluster of ION nodes. They state not having a consensus mechanism as a plus - which is debatable - logical centralization, uptime, adequate finality & DA guarantees matter a lot when dealing with identity. -->
<ul>
<li>
<p>Doesn't have a human-readable global name registry - lacks discoverability.</p>
</li>
<li>
<p>Doesn't have human-readable content addressing.</p>
</li>
<li>
<p>Focus is on users self-hosting their own data, running software locally &amp; handling keypairs.</p>
</li>
<li>
<p>Developing their own Decentralized Web Nodes (DWN) software that would be relaying messages p2p - can't handle <a href="principles.html#web-scale-blockspace--the-unix-philosophy">web-scale</a> on such a granular level and aggregation is not even in the picture.</p>
</li>
</ul>
<h1 id="cyberconnect"><a class="header" href="#cyberconnect"><a href="https://cyberconnect.me/">CyberConnect</a></a></h1>
<p>Built on the <a href="https://github.com/ceramicnetwork/ceramic/blob/main/SPECIFICATION.md">Ceramic protocol</a> &amp; <a href="https://ceramic.network/">network</a>.</p>
<p>TODO: working on incentives for pinning
https://twitter.com/joelthorst/status/1588863780301156352</p>
<ul>
<li>
<p>Requires the use of keypairs &amp; wallets.</p>
</li>
<li>
<p>Every user has their own Ceramic data stream on top of IPFS - it is yet to be proven that the DHT &amp; p2p layers can scale to hundreds of millions or billions of people.</p>
</li>
<li>
<p>The persistence of the social graph is handled by pinning IPFS data on nodes operated by them without any cryptoeconomic incentive for the data availability - it will grow into the tens/hundreds of terabytes for web-scale (Twitter scale: 400M users with 700 connections on average) - especially because they don't have a compact integer-based representation and everything is based on big individually signed actions. The upcoming Ceramic blockchain does not seem to be geared towards storage incentivization and will not be the solution to that.</p>
<blockquote>
<p>&quot;Long-term data retention on CyberConnect is guaranteed through Ceramic’s blockchain anchoring and a custom data pinning service.&quot; - <a href="https://blog.ceramic.network/building-the-social-graph-infrastructure-for-web3-0/">source</a></p>
</blockquote>
</li>
</ul>
<h1 id="deso"><a class="header" href="#deso"><a href="https://www.deso.org/">DeSo</a></a></h1>
<ul>
<li>
<p>It requires wallets &amp; users to pay for every interaction.</p>
</li>
<li>
<p>It puts everything on-chain and their plans to scale are with bigger blocks &amp; sharding (see <a href="https://docs.deso.org/about-deso-chain/readme">&quot;Phase 4: Sharding&quot;</a>) which is simply not practical for the <a href="principles.html#web-scale-blockspace--the-unix-philosophy">true scale of the public web</a>.</p>
</li>
<li>
<p>It financializes as much as possible (creator coins, etc.).</p>
</li>
<li>
<p>Their initial growth was fueled by huge sums of VC money but by now it has <a href="https://www.openprosper.com/stats/deso-dashboard">flatlined</a>. It did reach <a href="https://www.coingecko.com/en/coins/deso">1.66$ billion market cap</a> on the 2nd of October 2021 shortly after being listed.</p>
</li>
</ul>
<h1 id="others"><a class="header" href="#others">Others</a></h1>
<p>For details about ActivityPub, Matrix, Diaspora, Mastodon, Secure Scuttlebutt, Solid &amp; others please refer to the excellent <a href="https://twitter.com/bluesky/status/1352302821140549632">ecosystem review</a> by the Bluesky project. Other good resources include:</p>
<ul>
<li><a href="https://medium.com/decentralized-web/decentralized-social-networks-e5a7a2603f53">Decentralized Social Networks</a> - Jay Gerber</li>
<li><a href="https://medium.com/decentralized-web/blockchain-social-networks-c941fb337970">Blockchain Social Networks</a> - Jay Gerber</li>
<li>There are <a href="https://mirror.xyz/shreyjain.eth/TyBzMOegl3rMNxpAFoJ36MjE0pGfdLcrVCBgy-x3qS8">many other projects</a> in this space.</li>
</ul>
<!--

"a truly censorship-resistant alternative to Twitter that has a chance of working"
not really...
https://github.com/nostr-protocol/nostr

on mastodon
https://twitter.com/martinkl/status/1588823207284539392

The problem with Mastodon and similar programs
https://github.com/nostr-protocol/nostr#the-problem-with-mastodon-and-similar-programs
-->
<!-- <div style="text-align: center;">
    <img src="images/meme_one_does_not_simply.jpg">
</div> -->
<!-- one does not simply solve media
without logically centralizing identity, names, connections & anchoring through batching and custodial services
https://imgflip.com/memegenerator/One-Does-Not-Simply -->
<!-- <div style="text-align: center;">
    <img src="images/meme_expanding_brain.jpg">
</div> -->
<!-- trust centralized companies with your identity & data
use blockchains, self-host all your data, and sign every action
manage many keypair wallets and isolate risk
use a blockchain with hierarchical trust & don't require keypairs by default
https://imgflip.com/memegenerator/Expanding-Brain -->
<!-- <div style="text-align: center;">
    <img src="images/meme_drake_better_trust.jpg">
</div> -->
<!-- TRUSTLESS
manage keypairs & sign actions
BETTER TRUST
hierarchical trust & account management without keypairs by default
https://imgflip.com/memegenerator/Drake-Hotline-Bling -->
<!-- <div style="text-align: center;">
    <img src="images/meme_red_dress_better_trust.jpg">
</div> -->
<!-- better trust & familiar UX
normal people
using keypairs & signing actions trustlessly
https://imgflip.com/memegenerator/112528910/Guy-checks-out-red-dress-girl -->
<div style="break-before: page; page-break-before: always;"></div><div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>
<h1 id="execution-how"><a class="header" href="#execution-how">Execution (how)</a></h1>
<p>How the blockchain &amp; ecosystem are actually implemented (full specification).</p>
<!--
TODO: document with a "why not a rollup" section - or in the FAQ
https://twitter.com/KirilovVik/status/1531184971896999936
https://polynya.medium.com/the-sustainability-checklist-d620549425dc


Aside from the scalability properties rollups can possess, they also solve both fundamental problems. Rollups don’t need their own validators, only a set of sequencers to produce blocks. The base layer provides the secure validator set. Rollups that share a settlement layer can build trust-minimized bridges between them because their state transitions can be easily verified through the settlement layer.
https://www.alexbeckett.xyz/composability-in-a-rollup-ecosystem/

TODO: read these on rollups

https://celestia.org/learn/

https://www.alexbeckett.xyz/secure-light-nodes-and-the-scalability-trilemma/
https://www.alexbeckett.xyz/the-economics-for-rollup-fees/
https://www.alexbeckett.xyz/the-path-toward-scaling-rollups/
https://www.alexbeckett.xyz/the-benefits-of-optimistic-rollups-compared-to-zk-rollups/
https://www.alexbeckett.xyz/a-snapshot-of-the-current-rollup-ecosystem/
https://www.alexbeckett.xyz/decentralized-sequencers-where-do-we-go-next/

https://www.alexbeckett.xyz/stateless-rollups/

https://twitter.com/musalbas/status/1545060322842533890

https://twitter.com/apruden08/status/1542189323906326528
https://www.youtube.com/watch?v=oc8M1-pNuXk
https://twitter.com/bkiepuszewski/status/1540793333295075329

https://l2beat.com/?view=risk

https://medium.com/starkware/volition-and-the-emerging-data-availability-spectrum-87e8bfa09bb
https://medium.com/starkware/data-availability-e5564c416424

https://twitter.com/epolynya/status/1533833479896453120

https://eth.wiki/sharding/Sharding-FAQs


The theoretical ideal stack to build on would be
https://twitter.com/lukedelphi/status/1539192716915007490


https://twitter.com/ZeMariaMacedo/status/1543601695048998918


Why not a rollup? There is nothing to steal - there will not be 100x times TVL more than the mcap of the protocol

The more I think about it, the less need I see to try to attach my chain to Ethereum - it will not benefit from financial liquidity & interoperability since its focus is quite different and it will most likely require it's own token for PoS consensus

A big reason to want to attach to Ethereum is securely bridged financial liquidity so my use case will benefit a lot less from trying to integrate with Eth because of it's non-financial use case

No composability is broken if not linked to ethereum & is sharded - as is the case with financial blockchains

I think that because this is not a very financial use case that the incentive to link it strongly with Ethereum is smaller.

finance cares mostly about the present whereas an index is there to provide information about the past - different data availability & retrievability needs
the historical part is much more important - each block & the hashes that are contained in there - or they should enter the state...




- ZK rollup?
- eth2 danksharding?
- mina snapp?
- unbounded state growth.


Landslide Network
https://twitter.com/CosmosAVAX
https://www.landslide.network/





- look into aggregate/multi/threshold signatures, ZK tech & other certificates:
    https://github.com/jarradh/zk-compact-certificates



- ECDSA vs eddsa
https://support.mycrypto.com/how-to/getting-started/how-to-sign-and-verify-messages-on-ethereum/
https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7
https://ethvigil.com/docs/eth_sign_example_code/
https://crypto.stackexchange.com/questions/60383/what-is-the-difference-between-ecdsa-and-eddsa


https://vomtom.at/ethereum-private-and-public-keys/
https://betterprogramming.pub/understanding-ethereum-cryptography-3ef7429eddce
https://ethereum.stackexchange.com/questions/3542/how-are-ethereum-addresses-generated

Ethereum uses a specific signature scheme called ECDSA on a specific elliptic curve called Secp256k1.
the address is the last 20 bytes of the Keccak-256 hash of the public key.

This ensures that most apps do not end up hosting ECDSA key pairs which create security and regulatory challenges if funds are sent to them on Ethereum.
https://github.com/farcasterxyz/protocol/tree/varunsrin/revise-v2-dec-4#32-authentication


https://doc.libsodium.org/
http://ed25519.cr.yp.to/
https://keybase.io/
https://docs.joinmastodon.org/spec/webfinger/
https://docs.joinmastodon.org/spec/activitypub/


why libp2p sucks
https://twitter.com/tomaka17/status/1547529377277173761
https://github.com/matrix-org/pinecone

Skynet interop with IPFS:
https://twitter.com/DavidVorick/status/1412080832286584844
https://docs.skynetlabs.com/developer-guides/moving-from-ipfs-to-skynet
https://skynet.guide/tech/sia-layer-one.html
https://skynet.guide/tech/skynet-layer-two.html


reading on IPFS, Filecoin & Sia/Skynet
https://www.reddit.com/r/siacoin/comments/lg9qr0/what_is_skynet_why_should_i_build_on_it_and_how/gmr7u5v/
https://www.reddit.com/r/ipfs/comments/jf073z/filecoin_isnt_an_incentivization_network_for_ipfs/



how big are bloom filters
https://en.wikipedia.org/wiki/Bloom_filter
https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/
https://github.com/RoaringBitmap/CRoaring
https://github.com/RoaringBitmap/RoaringBitmap#faq
https://en.wikipedia.org/wiki/Bitmap_index




-->
<div style="break-before: page; page-break-before: always;"></div><div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>
<h1 id="identity-managers-idm"><a class="header" href="#identity-managers-idm">Identity managers (IDM)</a></h1>
<!--
# DMs

https://twitter.com/session_app
https://twitter.com/THORmaximalist/status/1590702991798984704

- DMs without keys - how?
    maybe rely on the identity providers - ACMs?
    https://twitter.com/elonmusk/status/1519469891455234048
    https://www.reddit.com/r/signal/comments/9k42k3/integrate_messaging_into_other_apps/
    https://www.youtube.com/watch?v=DXv1boalsDI
    https://www.youtube.com/watch?v=L2kuipP3lxk



- messaging protocol - XMTP & signal
https://en.wikipedia.org/wiki/Forward_secrecy
https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange
https://en.wikipedia.org/wiki/Double_Ratchet_Algorithm
https://chat.blockscan.com/start
https://twitter.com/etherscan/status/1577667362744020992

Whatsapp System design or software architecture
https://www.youtube.com/watch?v=L7LtmfFYjc4

Farcaster: Secure Messaging Requirements
https://www.youtube.com/watch?v=NDmKOnGherE
Farcaster: E2E Encryption
https://www.youtube.com/watch?v=eMGtBmN7qKE
Farcaster: Forward Secrecy
https://www.youtube.com/watch?v=xaejrsT4KDk


having everything from a user in a tree with a root hash - easier replication
https://github.com/bluesky-social/adx/blob/main/docs/architecture.md#personal-data-repositories



an IDM may also use a social recovery wallet instead of email as login - or just a normal wallet/keypair authorization

the more you rely on IDMs for features and data storage, the less sovereign you are.

security:
https://simplelogin.io/
https://twitter.com/SimpleLogin
https://haveibeenpwned.com/

an IDM should merge with your browsers

https://developer.apple.com/passkeys/

Today, advertisers blast and drip communications to users in hope of capturing attention at the right time. Tomorrow, advertisers can place a price on the cost of a message and pass along an embedded financial incentive for users to read it. We can imagine dynamic inboxes in the future where value can be attached to messages, and mail/messaging apps can automatically push value-laden messages to the top of the inbox. Inboxes themselves can monetize out of these rules, and give users flexibility to select filters or configurations that work while allowing advertisers to target high-value users.
https://multicoin.capital/2023/01/11/the-web3-growth-stack/



If an IDM does not let users bind keypairs then they should be boycotted

IDMs never get access to your private key


email and DMs should be the same thing

on DMs
http://www.backalleycoder.com/wp-content/uploads/2015/10/goat-to-cow-come-in-cow.jpg


query IDMs directly for content by person X - polling mechanics like RSS


https://solidproject.org/


DMs
https://github.com/farcasterxyz/protocol/issues/5


Permissions for different actions could be separated - for example requiring signatures for content while not requiring for updating follow connections.


access control

https://www.portis.io/
https://twitter.com/toruslabs
    https://tor.us/
https://twitter.com/Web3Auth



IDM - pay to cold-DM someone and be seen


- Blocking - through the IDM?
- how to keep progress bars for played audio/video? IDM?
- notifications - what is seen - managed between applications - IDM?



SOLVING THIS PROBLEM DeSo have thought about:
https://twitter.com/nadertheory/status/1480628981942525953
https://twitter.com/nadertheory/status/1480649481792024578


sessions as a concept? expiration of delegation?
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4361.md
https://eips.ethereum.org/EIPS/eip-4361








These are [accounts](accounts.md) that can grant the ability to applications to post on behalf of accounts that are under the control of the ACM in question.



Identity managers can still be compromised and wreck havok, but this is an improvement to the status quo
TODO: problem: what happens if an ACM with control of millions of accounts stops behaving properly?
- users without keypairs are screwed
- users with keypairs will be sending on-chain messages but those will be huge and will clog the network
    - possible solution: batch them off-chain into 1000 batches, construct BLS aggregate sigs, sign a msg & transmit that along with a bitmap for which keys participated in the batching to a block.
    Users will need to coordinate off-chain & decide from which block to revoke the access, which other ACM should be approved, etc. This can be used in other scenarios too.
    https://ethresear.ch/t/2105
    https://ethresear.ch/t/pragmatic-signature-aggregation-with-bls/2105
    https://ethresear.ch/t/5427
    https://our.status.im/fastest-bls-signature-implementation/
    OR use some ZK magic





https://fission.codes/blog/auth-without-backend/
https://ucan.xyz/
https://jwt.io/
 -->
<div style="break-before: page; page-break-before: always;"></div><div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>
<h1 id="handles-names"><a class="header" href="#handles-names">Handles (names)</a></h1>
<!-- A global mapping of `handle` (`string`) to X helps resolve queries. X contains:


subdomains.

- maybe they should not be properties of accounts but a separate map structure that just maps handles to IDs and on which block were they acquired? What would be traded - handles on IDs?

if a handle changes hands that shouldn't affect the ID & all the connections (no need to shuffle that much database numbers around)

- `handle` (`string`) - the name of the account
    - currently no idea how to 
    - TODO: https://en.wikipedia.org/wiki/Zooko%27s_triangle
- `handle_change`




needs hierarchy
    "what is the strongest case against global namespaces?"
    https://twitter.com/dystopiabreaker/status/1582516816307372032
    https://twitter.com/zooko/status/1434220535240482819

    maybe the protocol should lease whole TLDs to the highest bidders?



handles can be sold without affecting the interest graph - handles are not accounts.
entire accounts can be also sold with the transition to a new keypair

gradually lowering the cost for new handles, such that it costs 10k$ initially for a handle, and going lower slowly.


https://farcasterxyz.notion.site/Registry-Deep-Dive-4f4c74646bf24e8e905780719136f172

Names must be between 1 and 16 characters and can only be made of letters (a-z), numbers(0-9) and underscores (_).
^[a-zA-Z0-9-]{1,16}$
https://en.wikipedia.org/wiki/IDN_homograph_attack

UTF-8 support for handles opens handle users up to homograph attacks, not to mention case-sensitivity issues. This issue is of ongoing discussion both for the DSNP as well as in for ICANN domain names and other projects working with internationalization support.
https://spec.dsnp.org/Ethereum/Registry.html#homograph-attack-mitigation


**Register** 
Users acquire a name by making two transactions — the first is to commit a secret hash of the username, and the second is to reveal the secret and claim the username to the address. During the reveal phase it also:

commit-reveal scheme prevents frontrunning

- giving/leasing the names properly & orderly is a hard problem

https://medium.com/coinmonks/understanding-the-handshake-airdrop-and-reserved-names-428d9e90b560


TODO: maybe this should be together with addressing?

backwards-compatibility of the handles - can mimic typical DNS like "twitter.com"

TODO: strategy: reserve all handles that have 1-1 twitter & instagram versions

TODO: think about namespaces & hierarchies like in DNS & also ENS - is ENS a namespace?

!!!
https://farcasterxyz.notion.site/The-Identity-System-b5e320826b33460b845ccc9ada63e904


!!!
https://handshake.org/faq/
https://hsd-dev.org/
Another key differentiator is that Handshake is the first to pre-reserve names for existing trademark name holders.
TODO: DNS & TLS stuff...
Why is Handshake pre-reserving the top tens of thousands of domain names according to Alexa.com?
TODO: maybe also reserve the top 100k twitter handles?
TODO: Vickrey auction
    not that goot actually because humans aren't perfectly rational - "VCG mechanism"
    https://vitalik.ca/general/2021/09/26/limits.html#finance-is-the-absence-of-collusion-prevention
TODO: name renewals?
https://blog.sia.tech/handshake-retrospective-after-the-first-year-c197e49749c9
"The other major problem with Handshake auctions is that they are Vickrey auctions."
"Handshake would be a lot better if it had a bidding system that assumed users were unskilled and naive, and attempted to optimize the outcome for users assuming that they made bad or uninformed decisions."
"Proposed Improvements to the Domain Buying Process"


Web3 Leads to Cybersquatting 2.0: Here's What Brands Can Do
https://decrypt.co/104319/ethereum-name-web3-cybersquatting


"The mint happens over a two-phase commit reveal to prevent front-running registrations."
"Farcaster Names are ERC-721 tokens that are fully composable with the NFT ecosystem."
https://github.com/farcasterxyz/protocol

https://medium.com/@jgm.orinoco/domainsale-an-on-chain-secondary-ens-market-b3330f6e5dda

https://vitalik.ca/general/2022/09/09/ens.html
https://twitter.com/VitalikButerin/status/1568070721753989120


uts-46 normalization

https://daniel.haxx.se/blog/2022/12/14/idn-is-crazy/

when having multiple names, an account should specify their preferred one - possibly as a message type


ens is not enough - one size fits all aint good


Off-chain namespaces for handles? Dot something to be off-chain?

-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
