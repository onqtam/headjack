<div style="text-align: center;">
    <img src="https://png.pngitem.com/pimgs/s/207-2073499_translate-platform-from-english-to-spanish-work-in.png">
</div>


# Blocks, state & proofs, oh my!

<!-- 

Look at ethereum block & state structure
https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture
https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/


with small pieces of data the proofs for them could be orders of magnitude bigger - with Headjack storing them is not necessary as they can be derived from the original data blobs and the current state of the chain - a small core capable of producing the proofs for unlimited amounts of off-chain content

== there are 2 aspects when linking identity to a piece of data:

- merkle proof linking the data to a block
    - entities needs to keep either:
        - the full IPFS blobs and no merkle trees - can reconstruct a merkle proof for any piece of data at any time
        - or just the parts they care about + merkle proofs for each part to link them to a block
            - for multiple pieces of data can be optimized with merkle pollards and/or (sparse) multiproofs
    - if the state doesn't keep historical mapping of block numbers & identities to IPFS hashes:
        - there needs to be a merkle proof within the block
- merkle proofs linking identities to authorized services or keypairs at a specific block height




if the history of key rotations & revocations is not guaranteed, then data cannot be self-authenticating

events must be self-authenticating - and not requiring that the source (original creator) be always around to provide proofs for their authenticity.





- Graph with the proofs for a URI



TODO cache the merkle root & IPFS CID from blocks in the state?


if the blockchain doesn't store the full history of authorizations & keys forever then state merkle proofs will have to be saved at some point

    - Recursive merkleization of checkpointed L1 blocks/stateRoots so that anything can be referenced even with just the tip of the chain
    - https://en.wikipedia.org/wiki/Hash_array_mapped_trie
        CHAMP stands for Compressed Hash-Array Mapped Prefix-tree.
    - verkle trees

    optimizing merkle proofs
    https://medium.com/@jgm.orinoco/understanding-merkle-pollards-1547fc7efaa
    https://medium.com/@jgm.orinoco/understanding-sparse-merkle-multiproofs-9b9f049e8f08


# Block structure

- Transactions (token transfers)
- Registration/updates of applications
    - Sources for ephemeral content generated on the application - IPFS, Ceramic, HTTPS, etc.
- Blobs of data from each separate application
    - Follow/unfollow events
    - Update/delete account info/handle
    - Merkle root of all new content generated by the application
- Root hash of the state (connections, applications & accounts)



# What is in a block

- account actions
    - token transfers
    - IDM-like:
        - create new accounts without a keypair
        - binding & updating keypairs (changes require signature from the previous key)
        - list of application authorizations & revocations for accounts that it controls (each of which is just an integer pair - `56 => 661`)
    - Application-like:
        - content blob Merkle root
        - content blob IPFS CID
        - list of follow/unfollow actions for accounts (integers pairs - `67 => 27`)
        - Application-related info updates
            - IPFS node (cluster) address updates
            - keypair updates


- IDM batches
    - list of application authorizations & revocations (integers pairs - `56 => 661`)
    - follow/unfollow events (integers pairs - `67 => 27`)
    - keypair binding & changes (changes require signature from the previous key)
    - IDM-related info updates
- Application batches
    - follow/unfollow events (integers pairs - `67 => 27`)
    - content Merkle root
    - content blob IPFS CID 
    - Application-related info updates
        - IPFS node (cluster) address updates
        - keypair updates
- State root - the Merkle root for the latest materialized state

In reality a single account may play [all 3 roles](identity.md) - normal user, IDM & Application, so end users may even authorize applications & post content themselves as long as they have a keypair & the funds to pay for their direct on-chain transactions. The distinction here is to help paint the picture.

# Materialized state

For Headjack the state throughout history is much more important when compared to financial applications because there will be much more queries to prove things in the past (again and again) compared to just the present. Also, because 


TODO: does the state actually need to contain the historical mapping? not necessarily as third-party services could be doing that, but forcing full nodes to do it properly in the state & maintaining consensus would simplify the architecture of the rest


TODO: need examples & specifics for how big URI proofs would be


Make a graph with a block and txs and merkle roots




An account has the following properties:
- `ID` (`integer`) - unique on the blockchain, autoincrement, starting from 1
- `sig` - cryptographic address & signature
    - can be null ONLY if an `acm_id` is present
- `acm_id` (`integer`) - ACM ID - which [ACM](acm.md) can grant access to [applications](applications.md)
    - can be null ONLY if a `sig` is present

Other less important fields:

- `block_created` (`integer`) - in which block was the account first created

 -->

