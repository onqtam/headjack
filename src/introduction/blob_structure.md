# Blob structure & addressing

A major component of Headjack is how off-chain content is addressed. Interfaces accumulate activity from users which they cryptographically anchor in batches with a [Merkle root](https://en.wikipedia.org/wiki/Merkle_tree) which doesn't have to be on every block - those with little activity may submit only once per minute or even less often - the frequency is determined by publishing platforms based on the volume of activity and the on-chain costs for publishing bytes.

When enough activity has been collected, an interface constructs a blob and sorts all the events generated since the last anchored batch by grouping the activity by users and sorting them in some deterministic way & schema (users based on index/name and user interactions based on the type/sequence). The only signature required is from the interface for the entire blob.

Interfaces maintain the logical order of events for the future batch in maps in order to provide intra-blob addressing even before it is fully constructed - as an example if a user posts an article and immediately after that comments on their post - the comment should be able to refer to the post which is not yet committed on-chain. Interfaces will also display activity by others that is not yet anchored and the interactions can still use the proper addressing when referring to the yet-to-be-anchored messages (the next nonce number is predictable). Any type of interaction is addressable and sequenced in the blobs - including reactions (likes, etc).

When the blob is finalized a [Merkle root](https://en.wikipedia.org/wiki/Merkle_tree) is constructed (following a schema for deterministic merkleization) that touches every event and the [IPFS CID](https://docs.ipfs.io/concepts/content-addressing/) (hash) for the blob is generated. The only 2 things that are submitted on-chain are thus the Merkle root and the IPFS CID. Blobs have headers which contain the intra-blob index (offset table) for lookup of content of specific accounts. The blobs may be in a hierarchy such that the on-chain IPFS hash may point only to the "root" blob that contains the header/index and the actual indexed data could be in child IPFS blobs (whose [IPFS CID](https://docs.ipfs.io/concepts/content-addressing/) is contained in that header) so entities listening for events by specific accounts on Headjack may download only these headers and determine which "leaf" blobs they need to fetch for the data they are interested in (if any). Note that even private [intranet](https://en.wikipedia.org/wiki/Intranet) data may be anchored but not retrievable by the public if the IPFS blob is never actually hosted - unified addressing for public & private.

Interfaces are yet another on-chain account and they'll be able to associate a REST/RPC endpoint or any other means for direct contact by the rest of the interfaces so that they may ask for the yet unanchored messages and display them while they are still in the "mempool". They can also advertise the multiaddress of their IPFS nodes so that each successive blob of generated content that gets published can be downloaded by others instantly by manually connecting with IPFS’s [“swarm connect” functionality](https://medium.com/pinata/speeding-up-ipfs-pinning-through-swarm-connections-b509b1471986) - avoiding the use of the [DHT](https://en.wikipedia.org/wiki/Distributed_hash_table) for each new blob CID which may take tens of minutes. They can provide addresses to multiple IPFS nodes as a cluster for redundancy & horizontal scaling and use [Pinset orchestration for IPFS](https://ipfscluster.io/) - designed for Automated data availability and redundancy.
