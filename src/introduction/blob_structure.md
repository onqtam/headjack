# Blob structure & addressing

A major component of Headjack is how off-chain content is addressed. Interfaces accumulate activity from users which they cryptographically anchor in batches with a Merkle root which doesn't have to be on every block - those with little activity may submit only once per minute or even less often - the frequency is determined by publishing platforms based on the volume of activity and the on-chain costs for publishing bytes.

When enough activity has been collected, an interface constructs a blob and sorts all the events generated since the last anchored batch by grouping the activity by users and sorting them in some deterministic way (users based on index/name and user interactions based on the type/sequence).

Interfaces maintain the logical order of events for the future batch in maps in order to provide intra-blob addressing even before it is fully constructed - as an example if a user posts an article and immediately after that comments on their post - the comment should be able to refer to the post which is not yet committed on-chain. Interfaces will also display activity by others that is not yet anchored and the interactions can still use the proper addressing when referring to the yet-to-be-anchored messages (the next nonce to use will be known). Any type of interaction is addressable and sequenced in the blobs - including reactions (likes, etc).

When the blob is finalized a Merkle root is constructed that touches every event and the [IPFS CID](https://docs.ipfs.io/concepts/content-addressing/) (hash) for the blob is generated. The only 2 things that are submitted on-chain are thus the Merkle root and the IPFS CID. Blobs have headers which contain the intra-blob index (offset table) for lookup of content of specific accounts. The blobs may be in a hierarchy such that the on-chain IPFS hash may point only to the "root" blob that contains the header/index and the actual indexed data could be in child IPFS blobs so entities listening for events by specific accounts on Headjack may download only these headers and determine which "leaf" blobs they need to fetch for the data they are interested in (if any).

Interfaces are yet another on-chain account and they'll be able to associate a REST/RPC endpoint or any other means for direct contact by the rest of the interfaces so that they may ask for the yet unanchored messages and display them while they are still in the "mempool". They can also advertise the multiaddress of their IPFS nodes so that each successive blob of generated content that gets published can be downloaded by others instantly by manually connecting with IPFS’s [“swarm connect” functionality](https://medium.com/pinata/speeding-up-ipfs-pinning-through-swarm-connections-b509b1471986) - avoiding the use of the DHT for each new blob CID which may take tens of minutes. They can provide addresses to multiple IPFS nodes as a cluster for redundancy & horizontal scaling and use [Pinset orchestration for IPFS](https://ipfscluster.io/) - designed for Automated data availability and redundancy.
